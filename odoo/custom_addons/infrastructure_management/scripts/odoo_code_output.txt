







// [Folder] data








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\data\cron.xml
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data noupdate="1">
        <!-- Station Sync -->
        <record id="cron_sync_stations" model="ir.cron">
            <field name="name">Sync Infrastructure Stations</field>
            <field name="model_id" ref="model_infrastructure_station"/>
            <field name="state">code</field>
            <field name="code">model.sync_infrastructure(sync_stations=True)</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="active" eval="True"/>
            <field name="numbercall">-1</field>
            <field name="nextcall">2025-05-28 13:00:00</field>
        </record>

        <!-- Line Sync -->
        <record id="cron_sync_lines" model="ir.cron">
            <field name="name">Sync Infrastructure Lines</field>
            <field name="model_id" ref="model_infrastructure_line"/>
            <field name="state">code</field>
            <field name="code">model.sync_infrastructure(sync_lines=True)</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="active" eval="True"/>
            <field name="nextcall">2025-05-28 13:00:05</field>
        </record>

        <!-- Line Station Sync -->
        <record id="cron_sync_line_stations" model="ir.cron">
            <field name="name">Sync Infrastructure Line Stations</field>
            <field name="model_id" ref="model_infrastructure_line_station"/>
            <field name="state">code</field>
            <field name="code">model.sync_infrastructure(sync_line_stations=True)</field>
            <field name="interval_number">5</field>
            <field name="interval_type">minutes</field>
            <field name="numbercall">-1</field>
            <field name="active" eval="True"/>
            <field name="nextcall">2025-05-28 13:00:10</field>
        </record>
    </data>
</odoo>









// [Folder] models








//   [Folder] line








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line\line_crud.py
from odoo import models, api, _
from odoo.exceptions import UserError
import requests
import json
import logging

_logger = logging.getLogger(__name__)

class InfrastructureLine(models.Model):
    _inherit = 'infrastructure.line'

    @api.model
    def create(self, vals):
        if vals.get('schedule'):
            try:
                json.loads(vals['schedule'])
            except json.JSONDecodeError:
                raise UserError(_("%s must be a valid JSON string.") % "Schedule")

        if self._context.get('from_sync'):
            _logger.info("Creating line in Odoo from sync: %s (external_id: %s)", vals.get('enterprise_code'), vals.get('external_id'))
            return super(InfrastructureLine, self).create(vals)

        record = super(InfrastructureLine, self).create(vals)

        departure_station = record.departure_station_id
        terminus_station = record.terminus_station_id

        api_data = {
            'code': record.code,
            'color': record.color,
            'lineType': int(record.line_type) if record.line_type else 1,
            'enterpriseCode': record.enterprise_code,
            'departureStation': self._prepare_station_data(departure_station) if departure_station else {},
            'terminusStation': self._prepare_station_data(terminus_station) if terminus_station else {},
            'lineStations': [self._prepare_line_station_data(ls) for ls in record.line_station_ids],
            'schedule': json.loads(record.schedule) if record.schedule else []
        }

        try:
            api_url = 'http://147.93.52.105:9000/infra/line'
            payload = json.dumps(api_data, ensure_ascii=False).encode('utf-8')
            _logger.info("Sending POST request to: %s with payload: %s", api_url, payload.decode('utf-8'))
            response = requests.post(
                api_url,
                headers={'Content-Type': 'application/json; charset=utf-8'},
                data=payload,
                timeout=10
            )
            _logger.info("API POST %s response: %s (Status: %s)", api_url, response.text, response.status_code)
            if response.status_code == 201:
                try:
                    response_data = response.json()
                    external_id = response_data.get('id')
                    if not external_id:
                        raise ValueError("No external_id in JSON response")
                except json.JSONDecodeError:
                    response_text = response.text.strip()
                    if "Line created with id:" in response_text:
                        try:
                            external_id = int(response_text.split("Line created with id:")[1].strip())
                        except (IndexError, ValueError):
                            raise UserError(_(f"Failed to parse external_id from response: {response_text}"))
                    else:
                        raise UserError(_(f"Unexpected API response format: {response_text}"))
                
                self._cr.execute('UPDATE infrastructure_line SET external_id = %s WHERE id = %s', (external_id, record.id))
                _logger.info("Assigned external_id %s to line %s", external_id, record.enterprise_code)
            else:
                raise UserError(_(f"Failed to create line in API: {response.text} (Status: {response.status_code})"))
        except requests.RequestException as e:
            _logger.error("API POST request failed: %s", str(e))
            raise UserError(_(f"API request failed: {str(e)}"))

        return record

    def write(self, vals):
        if vals.get('schedule'):
            try:
                json.loads(vals['schedule'])
            except json.JSONDecodeError:
                raise UserError(_("%s must be a valid JSON string.") % "Schedule")

        result = super(InfrastructureLine, self).write(vals)

        if self._context.get('from_sync'):
            _logger.info("Skipping API update for line during sync: %s", self.enterprise_code)
            return result

        for record in self:
            if not record.external_id:
                _logger.warning("Skipping API update for line %s: No external_id.", record.enterprise_code or record.id)
                continue

            departure_station = record.departure_station_id
            terminus_station = record.terminus_station_id

            api_data = {
                'code': record.code,
                'color': record.color,
                'lineType': int(record.line_type) if record.line_type else 1,
                'enterpriseCode': record.enterprise_code,
                'departureStation': self._prepare_station_data(departure_station) if departure_station else {},
                'terminusStation': self._prepare_station_data(terminus_station) if terminus_station else {},
                'lineStations': [self._prepare_line_station_data(ls) for ls in record.line_station_ids],
                'schedule': json.loads(record.schedule) if record.schedule else []
            }

            try:
                api_url = f'http://147.93.52.105:9000/infra/line/{record.external_id}'
                payload = json.dumps(api_data, ensure_ascii=False).encode('utf-8')
                _logger.info("Sending PUT request to: %s with payload: %s", api_url, payload.decode('utf-8'))
                response = requests.put(
                    api_url,
                    headers={'Content-Type': 'application/json; charset=utf-8'},
                    data=payload,
                    timeout=10
                )
                _logger.info("API PUT %s response: %s (Status: %s)", api_url, response.text, response.status_code)
                if response.status_code not in (200, 201, 204):
                    raise UserError(_(f"Failed to update line in API: {response.text} (Status: {response.status_code})"))
            except requests.RequestException as e:
                _logger.error("API PUT request failed: %s", str(e))
                raise UserError(_(f"API request failed: {str(e)}"))

        return result

    def unlink(self):
        if self._context.get('from_sync'):
            _logger.info("Skipping API delete for line during sync: %s", self.enterprise_code)
            return super(InfrastructureLine, self).unlink()

        for record in self:
            if record.external_id:
                try:
                    api_url = f'http://147.93.52.105:9000/infra/line/{record.external_id}'
                    _logger.info("Sending DELETE request to: %s", api_url)
                    response = requests.delete(
                        api_url,
                        headers={'Content-Type': 'application/json'},
                        timeout=10
                    )
                    _logger.info("API DELETE %s response: %s (Status: %s)", api_url, response.text, response.status_code)
                    if response.status_code not in (200, 204):
                        _logger.warning(
                            "Failed to delete line %s in API: %s (Status: %s). Proceeding with Odoo deletion.",
                            record.enterprise_code or record.id, response.text, response.status_code
                        )
                except requests.RequestException as e:
                    _logger.error("API DELETE request failed for line %s: %s.", record.enterprise_code or record.id, str(e))
            else:
                _logger.info("Skipping API delete for line %s: No external_id.", record.enterprise_code or record.id)

        return super(InfrastructureLine, self).unlink()

    def _prepare_station_data(self, station):
        return {
            'id': station.external_id or station.id,
            'nameAr': station.name_ar or 'Unknown',
            'nameEn': station.name_en or 'Unknown',
            'nameFr': station.name_fr or 'Unknown',
            'lat': station.latitude or 0.0,
            'lng': station.longitude or 0.0,
            'paths': json.loads(station.paths) if station.paths else [],
            'lines': [line.external_id or line.id for line in station.line_ids],
            'schedule': json.loads(station.schedule) if station.schedule else [],
            'changes': json.loads(station.changes) if station.changes else {}
        }

    def _prepare_line_station_data(self, line_station):
        station = line_station.station_id
        return {
            'order': line_station.order,
            'stopDuration': line_station.stop_duration,
            'direction': line_station.direction,
            'station': self._prepare_station_data(station) if station else {},
            'radius': line_station.radius,
            'lat': line_station.lat or (station.latitude if station else 0.0),
            'lng': line_station.lng or (station.longitude if station else 0.0),
            'alertable': line_station.alertable,
            'efficient': line_station.efficient,
            'duration': line_station.duration
        }







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line\line_model.py
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class InfrastructureLine(models.Model):
    _name = 'infrastructure.line'
    _description = 'Infrastructure Line'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _rec_name = 'enterprise_code'

    code = fields.Char(
        string="Code", required=True, tracking=True)
    color = fields.Char(
        string="Color", default='#000000', tracking=True)
    line_type = fields.Selection(
        [('1', 'Type 1'), ('2', 'Type 2')],
        string='Line Type',
        default='1', tracking=True)
    enterprise_code = fields.Char(
        string="Enterprise Code", required=True, tracking=True)
    departure_station_id = fields.Many2one(
        'infrastructure.station',
        string='Departure Station', tracking=True)
    terminus_station_id = fields.Many2one(
        'infrastructure.station',
        string='Terminus Station', tracking=True)
    line_station_ids = fields.One2many(
        'infrastructure.line.station',
        'line_id',
        string='Line Stations', tracking=True)
    schedule = fields.Text(
        string="Schedule", default='[]', tracking=True)
    external_id = fields.Integer(
        string="External ID", index=True, readonly=True)

    def name_get(self):
        result = []
        for line in self:
            name = line.enterprise_code or line.code or f'Line {line.id}'
            _logger.debug("name_get for line ID %s: %s", line.id, name)
            result.append((line.id, name))
        return resultv







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line\line_sync.py
from odoo import models, api, _
from odoo.exceptions import UserError
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
import requests
import json
import logging
from datetime import datetime

_logger = logging.getLogger(__name__)

class InfrastructureLine(models.Model):
    _inherit = 'infrastructure.line'

    @api.model
    def sync_infrastructure(self, sync_stations=False, sync_lines=False, sync_line_stations=False):
        """
        Synchronize infrastructure data from API based on selected options.
        Fetches data from API, compares with Odoo DB, creates new records if needed,
        and updates existing ones without modifying the API.
        :param sync_stations: Boolean to sync stations
        :param sync_lines: Boolean to sync lines
        :param sync_line_stations: Boolean to sync line stations
        :return: dict with sync results
        """
        result = {
            'stations': {'synced': 0, 'skipped': 0},
            'lines': {'synced': 0, 'skipped': 0},
            'line_stations': {'synced': 0, 'skipped': 0},
            'messages': []
        }

        if not any([sync_stations, sync_lines, sync_line_stations]):
            raise UserError(_("Please select at least one entity to sync (Stations, Lines, or Line Stations)"))

        try:
            if sync_lines:
                api_url = 'http://147.93.52.105:9000/infra/line'
                _logger.info("Fetching all lines from API: %s", api_url)

                response = requests.get(
                    api_url,
                    headers={'Content-Type': 'application/json'},
                    timeout=30
                )
                
                if response.status_code != 200:
                    raise UserError(_(f"Failed to fetch lines from API: {response.text} (Status: {response.status_code})"))

                lines = response.json()
                _logger.info("API returned %s lines", len(lines))
                
                current_time = datetime.now().strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                self.env['ir.config_parameter'].sudo().set_param('infrastructure.line.last_sync', current_time)

                synced_count = 0
                skipped_count = 0
                api_line_ids = set()

                existing_lines = self.search([])
                existing_line_map = {line.external_id: line for line in existing_lines if line.external_id}

                for line in lines:
                    try:
                        external_id = line.get('id')
                        if not external_id:
                            _logger.warning("Skipping line with missing id: %s", line)
                            skipped_count += 1
                            continue

                        code = line.get('code', '')
                        enterprise_code = line.get('enterpriseCode', '')
                        
                        if not code or not enterprise_code or enterprise_code.lower() == 'test':
                            _logger.info(f"Skipping test or incomplete line with external_id {external_id}")
                            skipped_count += 1
                            continue

                        departure_station = None
                        if line.get('departureStation', {}).get('id'):
                            departure_station = self.env['infrastructure.station'].search(
                                [('external_id', '=', line['departureStation']['id'])], limit=1
                            )
                        terminus_station = None
                        if line.get('terminusStation', {}).get('id'):
                            terminus_station = self.env['infrastructure.station'].search(
                                [('external_id', '=', line['terminusStation']['id'])], limit=1
                            )

                        line_station_ids = []
                        for ls in line.get('lineStations', []):
                            if ls.get('station', {}).get('id'):
                                station = self.env['infrastructure.station'].search(
                                    [('external_id', '=', ls['station']['id'])], limit=1
                                )
                                if station:
                                    ls_record = self.env['infrastructure.line.station'].search([
                                        ('line_id.external_id', '=', external_id),
                                        ('station_id', '=', station.id),
                                        ('order', '=', ls.get('order', 0))
                                    ], limit=1)
                                    if not ls_record:
                                        ls_record = self.env['infrastructure.line.station'].with_context(from_sync=True).create({
                                            'line_id': False,
                                            'station_id': station.id,
                                            'order': ls.get('order', 0),
                                            'stop_duration': ls.get('stopDuration', 0),
                                            'direction': ls.get('direction', 'GOING'),
                                            'radius': ls.get('radius', 0),
                                            'lat': ls.get('lat', 0.0),
                                            'lng': ls.get('lng', 0.0),
                                            'alertable': ls.get('alertable', False),
                                            'efficient': ls.get('efficient', False),
                                            'duration': ls.get('duration', 0),
                                            'external_id': ls.get('id')
                                        })
                                    line_station_ids.append(ls_record.id)

                        line_data = {
                            'code': code,
                            'color': line.get('color', '#000000'),
                            'line_type': str(line.get('lineType', '1')),
                            'enterprise_code': enterprise_code,
                            'departure_station_id': departure_station.id if departure_station else False,
                            'terminus_station_id': terminus_station.id if terminus_station else False,
                            'schedule': json.dumps(line.get('schedule', [])),
                            'external_id': external_id
                        }

                        api_data_serialized = self._serialize_line_data(
                            line,
                            departure_station.id if departure_station else False,
                            terminus_station.id if departure_station else False,
                            line_station_ids
                        )

                        api_line_ids.add(external_id)

                        existing_line = existing_line_map.get(external_id)
                        if existing_line:
                            existing_data_serialized = self._serialize_existing_line(existing_line)
                            if existing_data_serialized == api_data_serialized:
                                _logger.debug(f"Skipping line with external_id {external_id}: No changes")
                                skipped_count += 1
                                continue

                            existing_line.with_context(from_sync=True).write(line_data)
                            existing_line.line_station_ids.unlink()
                            for ls_id in line_station_ids:
                                self.env['infrastructure.line.station'].browse(ls_id).write({'line_id': existing_line.id})
                            _logger.info(f"Updated line with external_id {external_id}")
                            synced_count += 1
                        else:
                            new_line = self.with_context(from_sync=True).create(line_data)
                            for ls_id in line_station_ids:
                                self.env['infrastructure.line.station'].browse(ls_id).write({'line_id': new_line.id})
                            _logger.info(f"Created line with external_id {external_id}")
                            synced_count += 1

                    except Exception as e:
                        _logger.error(f"Failed to process line {line.get('id', 'Unknown')}: {str(e)}")
                        skipped_count += 1

                lines_to_delete = [
                    line for line in existing_lines
                    if line.external_id and line.external_id not in api_line_ids
                ]

                for line in lines_to_delete:
                    try:
                        line.with_context(from_sync=True).unlink()
                        _logger.info(f"Deleted stale line with external_id {line.external_id}")
                    except Exception as e:
                        _logger.error(f"Failed to delete stale line {line.external_id}: {str(e)}")
                        skipped_count += 1

                result['lines'] = {'synced': synced_count, 'skipped': skipped_count}
                result['messages'].append(f"Lines sync completed: {synced_count} synced, {skipped_count} skipped")

            return result

        except requests.RequestException as e:
            error_message = f"Line sync failed: {str(e)}"
            _logger.error(error_message)
            raise UserError(_(error_message))

    @api.model
    def _serialize_line_data(self, line_data, departure_id, terminus_id, line_station_ids):
        data = {
            'code': line_data.get('code', ''),
            'color': line_data.get('color', ''),
            'line_type': str(line_data.get('lineType', '')),
            'enterprise_code': line_data.get('enterpriseCode', ''),
            'departure_station_id': departure_id,
            'terminus_station_id': terminus_id,
            'schedule': line_data.get('schedule', []) or [],
            'line_station_ids': sorted(line_station_ids)
        }
        return json.dumps(data, sort_keys=True)

    @api.model
    def _serialize_existing_line(self, line):
        data = {
            'code': line.code,
            'color': line.color,
            'line_type': line.line_type,
            'enterprise_code': line.enterprise_code,
            'departure_station_id': line.departure_station_id.id if line.departure_station_id else False,
            'terminus_station_id': line.terminus_station_id.id if line.terminus_station_id else False,
            'schedule': json.loads(line.schedule) if line.schedule else [],
            'line_station_ids': sorted(line.line_station_ids.ids)
        }
        return json.dumps(data, sort_keys=True)







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line\line_validation.py
from odoo import models, api, _
from odoo.exceptions import ValidationError
import json

class InfrastructureLine(models.Model):
    _inherit = 'infrastructure.line'

    @api.constrains('schedule')
    def _check_schedule(self):
        for record in self:
            if record.schedule:
                try:
                    json.loads(record.schedule)
                except json.JSONDecodeError:
                    raise ValidationError(_("%s must be a valid JSON string.") % "Schedule")







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line\__init__.py
from . import line_model
from . import line_crud
from . import line_sync
from . import line_validation









//   [Folder] line_station








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line_station\line_station_crud.py
from odoo import models, api, _
from odoo.exceptions import UserError
import requests
import json
import logging
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

_logger = logging.getLogger(__name__)

class InfrastructureLineStation(models.Model):
    _inherit = 'infrastructure.line.station'

    def _prepare_station_data(self, station):
        return {
            'id': station.external_id or station.id,
            'nameAr': station.name_ar or 'Unknown',
            'nameEn': station.name_en or 'Unknown',
            'nameFr': station.name_fr or 'Unknown',
            'lat': station.latitude or 0.0,
            'lng': station.longitude or 0.0,
            'paths': json.loads(station.paths) if station.paths else [],
            'lines': [line.external_id or line.id for line in station.line_ids],
            'schedule': json.loads(station.schedule) if station.schedule else [],
            'changes': json.loads(station.changes) if station.changes else {}
        }

    def _prepare_line_data(self, line):
        departure_station = line.departure_station_id
        terminus_station = line.terminus_station_id
        return {
            'id': line.external_id or line.id,
            'code': line.code or 'LINE',
            'color': line.color or '#000000',
            'departureStation': departure_station.name_en or 'Unknown' if departure_station else 'Unknown',
            'departureAddress': departure_station.name_en or 'Unknown' if departure_station else 'Unknown',
            'terminusStation': terminus_station.name_en or 'Unknown' if terminus_station else 'Unknown',
            'terminusAddress': terminus_station.name_en or 'Unknown' if terminus_station else 'Unknown',
            'schedule': json.loads(line.schedule) if line.schedule else ['08:00']
        }

    @api.model
    def create(self, vals):
        line_id = vals.get('line_id')
        direction = vals.get('direction')
        order = vals.get('order')
        if line_id and direction and order:
            existing = self.search([
                ('line_id', '=', line_id),
                ('direction', '=', direction),
                ('order', '=', order)
            ])
            if existing:
                raise UserError(_(
                    f"Order {order} is already used for line {existing.line_id.enterprise_code} "
                    f"in direction {direction}."
                ))

        if self._context.get('from_sync'):
            _logger.info("Creating line station in Odoo from sync: line_id=%s, station_id=%s (external_id: %s)",
                         vals.get('line_id'), vals.get('station_id'), vals.get('external_id'))
            return super(InfrastructureLineStation, self).create(vals)

        record = super(InfrastructureLineStation, self).create(vals)

        station = self.env['infrastructure.station'].browse(record.station_id.id)
        line = self.env['infrastructure.line'].browse(record.line_id.id)
        if not line.external_id or not station.external_id:
            _logger.warning("Skipping API POST for line station %s: Line or station missing external_id.", record.id)
            return record

        api_data = {
            'order': record.order,
            'stopDuration': record.stop_duration,
            'direction': record.direction,
            'radius': record.radius,
            'lat': record.lat or station.latitude or 0.0,
            'lng': record.lng or station.longitude or 0.0,
            'line': self._prepare_line_data(line),
            'station': self._prepare_station_data(station),
            'alertable': record.alertable,
            'efficient': record.efficient,
            'duration': record.duration
        }

        try:
            api_url = 'http://147.93.52.105:9000/infra/linestation'
            payload = json.dumps(api_data, ensure_ascii=False).encode('utf-8')
            _logger.info("Sending POST request to: %s with payload: %s", api_url, payload.decode('utf-8'))
            session = requests.Session()
            retries = Retry(total=3, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504])
            session.mount('http://', HTTPAdapter(max_retries=retries))
            response = session.post(
                api_url,
                headers={'Content-Type': 'application/json; charset=utf-8'},
                data=payload,
                timeout=10
            )
            _logger.info("API POST %s response: %s (Status: %s)", api_url, response.text, response.status_code)
            if response.status_code == 201:
                try:
                    response_data = response.json()
                    external_id = response_data.get('id')
                    if not external_id:
                        raise ValueError("No external_id in JSON response")
                except json.JSONDecodeError:
                    response_text = response.text.strip()
                    if "Line Station created with id:" in response_text:
                        try:
                            external_id = int(response_text.split("Line Station created with id:")[1].strip())
                        except (IndexError, ValueError):
                            raise UserError(_(f"Failed to parse external_id from response: {response_text}"))
                    else:
                        raise UserError(_(f"Unexpected API response format: {response_text}"))
                
                self._cr.execute('UPDATE infrastructure_line_station SET external_id = %s WHERE id = %s', (external_id, record.id))
                _logger.info("Assigned external_id %s to line station %s", external_id, record.id)
            else:
                raise UserError(_(f"Failed to create line station in API: {response.text} (Status: {response.status_code})"))
        except requests.RequestException as e:
            _logger.error("API POST request failed: %s", str(e))
            raise UserError(_(f"API request failed: {str(e)}"))

        return record

    def write(self, vals):
        if self._context.get('from_sync'):
            _logger.info("Skipping API update for line station during sync: %s", self.id)
            return super(InfrastructureLineStation, self).write(vals)

        result = super(InfrastructureLineStation, self).write(vals)

        for record in self:
            if not record.external_id:
                _logger.warning("Skipping API update for line station %s: No external_id.", record.id)
                continue

            station = self.env['infrastructure.station'].browse(record.station_id.id)
            line = self.env['infrastructure.line'].browse(record.line_id.id)
            api_data = {
                'order': record.order,
                'stopDuration': record.stop_duration,
                'direction': record.direction,
                'radius': record.radius,
                'lat': record.lat or station.latitude or 0.0,
                'lng': record.lng or station.longitude or 0.0,
                'line': self._prepare_line_data(line),
                'station': self._prepare_station_data(station),
                'alertable': record.alertable,
                'efficient': record.efficient,
                'duration': record.duration
            }

            try:
                api_url = f'http://147.93.52.105:9000/infra/linestation/{record.external_id}'
                payload = json.dumps(api_data, ensure_ascii=False).encode('utf-8')
                _logger.info("Sending PUT request to: %s with payload: %s", api_url, payload.decode('utf-8'))
                session = requests.Session()
                retries = Retry(total=3, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504])
                session.mount('http://', HTTPAdapter(max_retries=retries))
                response = session.put(
                    api_url,
                    headers={'Content-Type': 'application/json; charset=utf-8'},
                    data=payload,
                    timeout=10
                )
                _logger.info("API PUT %s response: %s (Status: %s)", api_url, response.text, response.status_code)
                if response.status_code not in (200, 201, 204):
                    raise UserError(_(f"Failed to update line station in API: {response.text} (Status: {response.status_code})"))
            except requests.RequestException as e:
                _logger.error("API PUT request failed: %s", str(e))
                raise UserError(_(f"API request failed: {str(e)}"))

        return result

    def unlink(self):
        if self._context.get('from_sync'):
            _logger.info("Skipping API delete for line station during sync: %s", self.ids)
            return super(InfrastructureLineStation, self).unlink()

        for record in self:
            if record.external_id:
                try:
                    api_url = f'http://147.93.52.105:9000/infra/linestation/{record.external_id}'
                    _logger.info("Sending DELETE request to: %s for line station %s (external_id: %s)",
                                 api_url, record.id, record.external_id)
                    session = requests.Session()
                    retries = Retry(total=3, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504])
                    session.mount('http://', HTTPAdapter(max_retries=retries))
                    response = session.delete(
                        api_url,
                        headers={'Content-Type': 'application/json'},
                        timeout=10
                    )
                    _logger.info("API DELETE %s response: %s (Status: %s)", api_url, response.text, response.status_code)
                    if response.status_code not in (200, 204):
                        _logger.warning(
                            "Failed to delete line station %s in API: %s (Status: %s). Proceeding with Odoo deletion.",
                            record.id, response.text, response.status_code
                        )
                except requests.RequestException as e:
                    _logger.error("API DELETE request failed for line station %s (external_id: %s): %s",
                                  record.id, record.external_id, str(e))
                    # Proceed with Odoo deletion despite API failure
            else:
                _logger.info("Skipping API delete for line station %s: No external_id.", record.id)

        return super(InfrastructureLineStation, self).unlink()







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line_station\line_station_model.py
from odoo import models, fields, api
import logging

_logger = logging.getLogger(__name__)

class InfrastructureLineStation(models.Model):
    _name = 'infrastructure.line.station'
    _description = 'Infrastructure Line Station'
    _inherit = ['mail.thread', 'mail.activity.mixin']

    order = fields.Integer(
        string='Order', required=True, tracking=True)
    stop_duration = fields.Integer(
        string='Stop Duration', default=0, tracking=True)
    direction = fields.Selection(
        [('GOING', 'Going'), ('RETURNING', 'Returning')],
        string='Direction',
        required=True, tracking=True)
    radius = fields.Integer(
        string='Radius', default=0, tracking=True)
    lat = fields.Float(
        string='Latitude', default=0.0, tracking=True)
    lng = fields.Float(
        string='Longitude', default=0.0, tracking=True)
    line_id = fields.Many2one(
        'infrastructure.line',
        string='Line',
        required=True, tracking=True)
    station_id = fields.Many2one(
        'infrastructure.station',
        string='Station',
        required=True, tracking=True)
    alertable = fields.Boolean(
        string='Alertable', default=False, tracking=True)
    efficient = fields.Boolean(
        string='Efficient', default=False, tracking=True)
    duration = fields.Integer(
        string='Duration', default=0, tracking=True)
    external_id = fields.Integer(
        string='External ID', readonly=True, index=True)
    location_picker = fields.Boolean(
        string='Location Picker', default=True)







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line_station\line_station_sync.py
from odoo import models, api, _
from odoo.exceptions import UserError
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
import requests
import json
import logging
from datetime import datetime

_logger = logging.getLogger(__name__)

class InfrastructureLineStation(models.Model):
    _inherit = 'infrastructure.line.station'

    @api.model
    def sync_infrastructure(self, sync_stations=False, sync_lines=False, sync_line_stations=False):
        """
        Synchronize infrastructure data from API based on selected options.
        Fetches data from API, compares with Odoo DB, creates new records if needed,
        and updates existing ones without modifying the API.
        :param sync_stations: Boolean to sync stations
        :param sync_lines: Boolean to sync lines
        :param sync_line_stations: Boolean to sync line stations
        :return: dict with sync results
        """
        result = {
            'stations': {'synced': 0, 'skipped': 0},
            'lines': {'synced': 0, 'skipped': 0},
            'line_stations': {'synced': 0, 'skipped': 0},
            'messages': []
        }

        if not any([sync_stations, sync_lines, sync_line_stations]):
            raise UserError(_("Please select at least one entity to sync (Stations, Lines, or Line Stations)"))

        if sync_line_stations:
            _logger.info("Starting line stations sync from API")

            lines = self.env['infrastructure.line'].search([('external_id', '!=', False)])
            if not lines:
                _logger.warning("No lines with external_id found for line station sync")
                result['line_stations'] = {'synced': 0, 'skipped': 0}
                result['messages'].append("No lines available to sync line stations")
                return result

            synced_count = 0
            skipped_count = 0
            api_ls_ids = set()

            existing_ls = self.search([])
            existing_ls_map = {ls.external_id: ls for ls in existing_ls if ls.external_id}

            directions = ['GOING', 'RETURNING']
            for line in lines:
                for direction in directions:
                    api_url = f'http://147.93.52.105:9000/infra/linestation?lineId={line.external_id}&direction={direction}'
                    _logger.info("Fetching line stations for line %s (external_id: %s, direction: %s) from API: %s",
                                line.enterprise_code, line.external_id, direction, api_url)

                    try:
                        response = requests.get(api_url, headers={'Content-Type': 'application/json'}, timeout=30)
                        if response.status_code != 200:
                            _logger.error("Failed to fetch line stations for line %s, direction %s: %s (Status: %s)",
                                        line.external_id, direction, response.text, response.status_code)
                            skipped_count += 1
                            continue

                        try:
                            line_stations = response.json()
                        except json.JSONDecodeError:
                            _logger.error("Failed to parse JSON response for line %s, direction %s: %s",
                                        line.external_id, direction, response.text)
                            skipped_count += 1
                            continue

                        if line_stations is None:
                            _logger.warning("API returned None for line %s, direction %s", line.external_id, direction)
                            skipped_count += 1
                            continue

                        if not isinstance(line_stations, list):
                            _logger.warning("Invalid API response for line %s, direction %s: Expected list, got %s",
                                            line.external_id, direction, type(line_stations).__name__)
                            skipped_count += 1
                            continue

                        _logger.info("API returned %s line stations for line %s (external_id: %s, direction: %s)",
                                    len(line_stations), line.enterprise_code, line.external_id, direction)

                        for ls in line_stations:
                            try:
                                external_id = ls.get('id')
                                if not external_id:
                                    _logger.warning("Skipping line station with missing id for line %s, direction %s: %s",
                                                    line.external_id, direction, ls)
                                    skipped_count += 1
                                    continue

                                line_id = ls.get('line', {}).get('id')
                                station_id = ls.get('station', {}).get('id')
                                if not line_id or not station_id:
                                    _logger.warning("Skipping incomplete line station with external_id %s for line %s, direction %s",
                                                    external_id, line.external_id, direction)
                                    skipped_count += 1
                                    continue

                                line_record = self.env['infrastructure.line'].search([('external_id', '=', line_id)], limit=1)
                                station = self.env['infrastructure.station'].search([('external_id', '=', station_id)], limit=1)
                                if not line_record or not station:
                                    _logger.warning("Skipping line station %s: Line %s or station %s not found",
                                                    external_id, line_id, station_id)
                                    skipped_count += 1
                                    continue

                                ls_data = {
                                    'line_id': line_record.id,
                                    'station_id': station.id,
                                    'order': ls.get('order', 0),
                                    'stop_duration': ls.get('stopDuration', 0),
                                    'direction': ls.get('direction', 'GOING').upper(),
                                    'radius': ls.get('radius', 0),
                                    'lat': float(ls.get('lat', 0.0)),
                                    'lng': float(ls.get('lng', 0.0)),
                                    'alertable': ls.get('alertable', False),
                                    'efficient': ls.get('efficient', False),
                                    'duration': ls.get('duration', 0),
                                    'external_id': external_id,
                                    'location_picker': True
                                }

                                api_data_serialized = self._serialize_line_station_data(ls, line_record.id, station.id)
                                existing_ls_record = existing_ls_map.get(external_id)

                                if existing_ls_record:
                                    existing_data_serialized = self._serialize_existing_line_station(existing_ls_record)
                                    if existing_data_serialized == api_data_serialized:
                                        _logger.debug("Skipping line station with external_id %s: No changes", external_id)
                                        skipped_count += 1
                                        continue
                                    existing_ls_record.with_context(from_sync=True).write(ls_data)
                                    _logger.info("Updated line station with external_id %s for line %s, direction %s",
                                                external_id, line.external_id, direction)
                                    synced_count += 1
                                else:
                                    self.with_context(from_sync=True).create(ls_data)
                                    _logger.info("Created line station with external_id %s for line %s, direction %s",
                                                external_id, line.external_id, direction)
                                    synced_count += 1

                                api_ls_ids.add(external_id)

                            except Exception as e:
                                _logger.error("Failed to process line station %s for line %s, direction %s: %s",
                                            ls.get('id', 'Unknown'), line.external_id, direction, str(e))
                                skipped_count += 1
                                continue

                    except requests.RequestException as e:
                        _logger.error("API request failed for line %s, direction %s: %s", line.external_id, direction, str(e))
                        skipped_count += 1
                        if '404' in str(e):
                            _logger.warning("No line stations available for line %s, direction %s (Status: 404)",
                                            line.external_id, direction)
                        continue

            ls_to_delete = [
                ls for ls in existing_ls
                if ls.external_id and ls.external_id not in api_ls_ids
            ]

            for ls in ls_to_delete:
                try:
                    ls.with_context(from_sync=True).unlink()
                    _logger.info("Deleted stale line station with external_id %s", ls.external_id)
                    synced_count += 1
                except Exception as e:
                    _logger.error("Failed to delete stale line station %s: %s", ls.external_id, str(e))
                    skipped_count += 1

            current_time = datetime.now().strftime(DEFAULT_SERVER_DATETIME_FORMAT)
            self.env['ir.config_parameter'].sudo().set_param('infrastructure.line.station.last_sync', current_time)

            result['line_stations'] = {'synced': synced_count, 'skipped': skipped_count}
            result['messages'].append(f"Line stations sync completed: {synced_count} synced, {skipped_count} skipped")

        return result

    @api.model
    def _serialize_line_station_data(self, ls_data, line_id, station_id):
        data = {
            'order': ls_data.get('order', 0),
            'stop_duration': ls_data.get('stopDuration', 0),
            'direction': ls_data.get('direction', 'GOING'),
            'radius': ls_data.get('radius', 0),
            'lat': float(ls_data.get('lat', 0.0)),
            'lng': float(ls_data.get('lng', 0.0)),
            'alertable': ls_data.get('alertable', False),
            'efficient': ls_data.get('efficient', False),
            'duration': ls_data.get('duration', 0),
            'line_id': line_id,
            'station_id': station_id
        }
        return json.dumps(data, sort_keys=True)

    @api.model
    def _serialize_existing_line_station(self, ls):
        data = {
            'order': ls.order,
            'stop_duration': ls.stop_duration,
            'direction': ls.direction,
            'radius': ls.radius,
            'lat': ls.lat,
            'lng': ls.lng,
            'alertable': ls.alertable,
            'efficient': ls.efficient,
            'duration': ls.duration,
            'line_id': ls.line_id.id if ls.line_id else False,
            'station_id': ls.station_id.id if ls.station_id else False
        }
        return json.dumps(data, sort_keys=True)







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line_station\line_station_validation.py
from odoo import models, api, _
from odoo.exceptions import ValidationError

class InfrastructureLineStation(models.Model):
    _inherit = 'infrastructure.line.station'

    @api.constrains('lat', 'lng')
    def _check_coordinates(self):
        for record in self:
            if record.lat and (record.lat < -90 or record.lat > 90):
                raise ValidationError(_("Latitude must be between -90 and 90 degrees."))
            if record.lng and (record.lng < -180 or record.lng > 180):
                raise ValidationError(_("Longitude must be between -180 and 180 degrees."))

    @api.constrains('order', 'line_id', 'direction')
    def _check_unique_order(self):
        for record in self:
            duplicates = self.search([
                ('line_id', '=', record.line_id.id),
                ('direction', '=', record.direction),
                ('order', '=', record.order),
                ('id', '!=', record.id)
            ])
            if duplicates:
                raise ValidationError(_(
                    f"Order {record.order} is already used for line {record.line_id.enterprise_code} "
                    f"in direction {record.direction}."
                ))







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\line_station\__init__.py
from . import line_station_model
from . import line_station_crud
from . import line_station_sync
from . import line_station_validation









//   [Folder] station








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\station\station.py
from odoo import models, fields, api, _
import json

class InfrastructureStation(models.Model):
    _name = 'infrastructure.station'
    _description = 'Infrastructure Station'
    _inherit = ['mail.thread', 'mail.activity.mixin']
    _rec_name = 'name_en'

    name_ar = fields.Char(
        string="Name (Arabic)", required=True, tracking=True)
    name_en = fields.Char(
        string="Name (English)", required=True, tracking=True)
    name_fr = fields.Char(
        string="Name (French)", required=True, tracking=True)
    latitude = fields.Float(
        string="Latitude", digits=(9, 6), default=36.7538, tracking=True)
    longitude = fields.Float(
        string="Longitude", digits=(9, 6), default=3.0588, tracking=True)
    line_ids = fields.Many2many(
        'infrastructure.line', string="Lines", tracking=True)
    paths = fields.Text(
        string="Paths", default='[]', tracking=True)
    changes = fields.Text(
        string="Changes", default='{}', tracking=True)
    schedule = fields.Text(
        string="Schedule", default='[]', tracking=True)
    external_id = fields.Integer(
        string="External ID", index=True, readonly=True)
    location_picker = fields.Boolean(string='Location Picker', default=True)

    







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\station\station_crud.py
from odoo import models, api, _
from odoo.exceptions import UserError, ValidationError
import requests
import json
import logging

_logger = logging.getLogger(__name__)

class InfrastructureStation(models.Model):
    _inherit = 'infrastructure.station'

    @api.model
    def create(self, vals):
        for field in ['paths', 'changes', 'schedule']:
            if vals.get(field):
                try:
                    json.loads(vals[field])
                except json.JSONDecodeError:
                    raise UserError(_("%s must be a valid JSON string.") % field.capitalize())

        if self._context.get('from_sync'):
            _logger.info("Creating station in Odoo from sync: %s (external_id: %s)", vals.get('name_en'), vals.get('external_id'))
            return super(InfrastructureStation, self).create(vals)

        record = super(InfrastructureStation, self).create(vals)

        api_data = {
            'nameAr': record.name_ar,
            'nameEn': record.name_en,
            'nameFr': record.name_fr,
            'lat': record.latitude or 0.0,
            'lng': record.longitude or 0.0,
            'paths': json.loads(record.paths) if record.paths else [],
            'lines': [line.external_id or line.id for line in record.line_ids],
            'changes': json.loads(record.changes) if record.changes else {},
            'schedule': json.loads(record.schedule) if record.schedule else []
        }

        try:
            api_url = 'http://147.93.52.105:9000/infra/station'
            payload = json.dumps(api_data, ensure_ascii=False).encode('utf-8')
            _logger.info("Sending POST request to: %s with payload: %s", api_url, payload.decode('utf-8'))
            response = requests.post(
                api_url,
                headers={'Content-Type': 'application/json; charset=utf-8'},
                data=payload,
                timeout=10
            )
            _logger.info("API POST %s response: %s (Status: %s)", api_url, response.text, response.status_code)
            if response.status_code == 201:
                try:
                    response_data = response.json()
                    external_id = response_data.get('id')
                    if not external_id:
                        raise ValueError("No external_id found in JSON response")
                except json.JSONDecodeError:
                    response_text = response.text.strip()
                    if "Created Station with id:" in response_text:
                        try:
                            external_id = int(response_text.split("Created Station with id:")[1].strip())
                        except (IndexError, ValueError):
                            _logger.error("Unable to parse external_id from text response: %s", response_text)
                            raise UserError(_(f"Failed to parse external_id from API response: {response_text}"))
                    else:
                        _logger.error("Unexpected response format: %s", response_text)
                        raise UserError(_(f"Unexpected API response format: {response_text}"))
                
                self._cr.execute('UPDATE infrastructure_station SET external_id = %s WHERE id = %s', (external_id, record.id))
                _logger.info("Assigned external_id %s to station %s", external_id, record.name_en)
            else:
                raise UserError(_(f"Failed to create station in API: {response.text} (Status: {response.status_code})"))
        except requests.RequestException as e:
            _logger.error("API POST request failed: %s", str(e))
            raise UserError(_(f"API request failed: {str(e)}"))

        return record

    def write(self, vals):
        for field in ['paths', 'changes', 'schedule']:
            if vals.get(field):
                try:
                    json.loads(vals[field])
                except json.JSONDecodeError:
                    raise UserError(_("%s must be a valid JSON string.") % field.capitalize())

        if self._context.get('from_sync'):
            _logger.info("Skipping API update for station during sync: %s", self.name_en)
            return super(InfrastructureStation, self).write(vals)

        result = super(InfrastructureStation, self).write(vals)

        for record in self:
            if not record.external_id:
                _logger.warning("Skipping API update for station %s: No external_id.", record.name_en or record.id)
                continue

            api_data = {
                'nameAr': record.name_ar,
                'nameEn': record.name_en,
                'nameFr': record.name_fr,
                'lat': record.latitude or 0.0,
                'lng': record.longitude or 0.0,
                'paths': json.loads(record.paths) if record.paths else [],
                'lines': [line.external_id or line.id for line in record.line_ids],
                'changes': json.loads(record.changes) if record.changes else {},
                'schedule': json.loads(record.schedule) if record.schedule else []
            }

            try:
                api_url = f'http://147.93.52.105:9000/infra/station/{record.external_id}'
                payload = json.dumps(api_data, ensure_ascii=False).encode('utf-8')
                _logger.info("Sending PUT request to: %s with payload: %s", api_url, payload.decode('utf-8'))
                response = requests.put(
                    api_url,
                    headers={'Content-Type': 'application/json; charset=utf-8'},
                    data=payload,
                    timeout=10
                )
                _logger.info("API PUT %s response: %s (Status: %s)", api_url, response.text, response.status_code)
                if response.status_code not in (200, 201, 204):
                    raise UserError(_(f"Failed to update station in API: {response.text} (Status: {response.status_code})"))
            except requests.RequestException as e:
                _logger.error("API PUT request failed: %s", str(e))
                raise UserError(_(f"API request failed: {str(e)}"))

        return result

    def unlink(self):
        if self._context.get('from_sync'):
            _logger.info("Skipping API delete for station during sync: %s", self.name_en)
            return super(InfrastructureStation, self).unlink()

        for record in self:
            if record.external_id:
                try:
                    api_url = f'http://147.93.52.105:9000/infra/station/{record.external_id}'
                    _logger.info("Sending DELETE request to: %s", api_url)
                    response = requests.delete(
                        api_url,
                        headers={'Content-Type': 'application/json'},
                        timeout=10
                    )
                    _logger.info("API DELETE %s response: %s (Status: %s)", api_url, response.text, response.status_code)
                    if response.status_code not in (200, 204):
                        _logger.warning(
                            "Failed to delete station %s in API: %s (Status: %s). Proceeding with Odoo deletion.",
                            record.name_en or record.id, response.text, response.status_code
                        )
                except requests.RequestException as e:
                    _logger.error("API DELETE request failed for station %s: %s.", record.name_en or record.id, str(e))
            else:
                _logger.info("Skipping API delete for station %s: No external_id.", record.name_en or record.id)

        return super(InfrastructureStation, self).unlink()







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\station\station_sync.py
from odoo import models, api, _
from odoo.exceptions import UserError
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT
import requests
import logging
import json
from datetime import datetime

_logger = logging.getLogger(__name__)

class InfrastructureStation(models.Model):
    _inherit = 'infrastructure.station'

    @api.model
    def sync_infrastructure(self, sync_stations=False, sync_lines=False, sync_line_stations=False):
        result = {
            'stations': {'synced': 0, 'skipped': 0},
            'lines': {'synced': 0, 'skipped': 0},
            'line_stations': {'synced': 0, 'skipped': 0},
            'messages': []
        }

        if not any([sync_stations, sync_lines, sync_line_stations]):
            raise UserError(_("Please select at least one entity to sync (Stations, Lines, or Line Stations)"))

        try:
            if sync_stations:
                api_url = 'http://147.93.52.105:9000/infra/station'
                _logger.info("Fetching all stations from API: %s", api_url)
                response = requests.get(api_url, headers={'Content-Type': 'application/json'}, timeout=30)
                if response.status_code != 200:
                    raise UserError(_(f"Failed to fetch stations from API: {response.text} (Status: {response.status_code})"))

                stations = response.json()
                _logger.info("API returned %s stations", len(stations))

                synced_count = 0
                skipped_count = 0
                existing_stations = self.search([('external_id', '!=', False)])
                existing_station_map = {station.external_id: station for station in existing_stations}

                for station in stations:
                    external_id = station.get('id')
                    if not external_id:
                        _logger.warning("Skipping station with missing id: %s", station)
                        skipped_count += 1
                        continue

                    name_ar = station.get('nameAr', '')
                    name_en = station.get('nameEn', '')
                    name_fr = station.get('nameFr', '')
                    if any(name.lower().startswith('test') for name in [name_ar, name_en, name_fr]) or not all([name_ar, name_en, name_fr]):
                        _logger.info(f"Skipping test or incomplete station with external_id {external_id}")
                        skipped_count += 1
                        continue

                    line_ids = []
                    for line_id in station.get('lines', []):
                        line = self.env['infrastructure.line'].search([('external_id', '=', line_id)], limit=1)
                        if line:
                            line_ids.append(line.id)

                    station_data = {
                        'name_ar': name_ar,
                        'name_en': name_en,
                        'name_fr': name_fr,
                        'latitude': float(station.get('lat', 36.7538)),
                        'longitude': float(station.get('lng', 3.0588)),
                        'paths': json.dumps(station.get('paths', [])),
                        'changes': json.dumps(station.get('changes', {}) or {}),
                        'schedule': json.dumps(station.get('schedule', [])),
                        'line_ids': [(6, 0, line_ids)],
                        'external_id': external_id,
                        'location_picker': True
                    }

                    api_data_serialized = self._serialize_station_data(station, line_ids)
                    existing_station = existing_station_map.get(external_id)

                    if existing_station:
                        existing_data_serialized = self._serialize_existing_station(existing_station)
                        if existing_data_serialized == api_data_serialized:
                            _logger.debug(f"Skipping station with external_id {external_id}: No changes")
                            skipped_count += 1
                            continue
                        existing_station.with_context(from_sync=True).write(station_data)
                        _logger.info(f"Updated station with external_id {external_id}")
                        synced_count += 1
                    else:
                        self.with_context(from_sync=True).create(station_data)
                        _logger.info(f"Created station with external_id {external_id}")
                        synced_count += 1

                result['stations'] = {'synced': synced_count, 'skipped': skipped_count}
                result['messages'].append(f"Stations sync completed: {synced_count} synced, {skipped_count} skipped")

                current_time = datetime.now().strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                self.env['ir.config_parameter'].sudo().set_param('infrastructure.station.last_sync', current_time)

            return result

        except Exception as e:
            _logger.error("Infrastructure sync failed: %s", str(e))
            raise UserError(_(f"Infrastructure sync failed: {str(e)}"))







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\station\station_validation.py
from odoo import models, api, _
from odoo.exceptions import ValidationError
import json

class InfrastructureStation(models.Model):
    _inherit = 'infrastructure.station'

    @api.constrains('latitude', 'longitude')
    def _check_coordinates(self):
        for record in self:
            if record.latitude and (record.latitude < -90 or record.latitude > 90):
                raise ValidationError(_("Latitude must be between -90 and 90 degrees."))
            if record.longitude and (record.longitude < -180 or record.longitude > 180):
                raise ValidationError(_("Longitude must be between -180 and 180 degrees."))

    @api.constrains('paths', 'changes', 'schedule')
    def _check_json_fields(self):
        for record in self:
            for field in ['paths', 'changes', 'schedule']:
                if record[field]:
                    try:
                        json.loads(record[field])
                    except json.JSONDecodeError:
                        raise ValidationError(_("%s must be a valid JSON string.") % field.capitalize())

    @api.model
    def _serialize_station_data(self, station_data, line_ids):
        data = {
            'name_ar': station_data.get('nameAr', ''),
            'name_en': station_data.get('nameEn', ''),
            'name_fr': station_data.get('nameFr', ''),
            'latitude': float(station_data.get('lat', 0.0)),
            'longitude': float(station_data.get('lng', 0.0)),
            'paths': station_data.get('paths', []) or [],
            'changes': station_data.get('changes', {}) or {},
            'schedule': station_data.get('schedule', []) or [],
            'line_ids': sorted(line_ids)
        }
        return json.dumps(data, sort_keys=True)

    @api.model
    def _serialize_existing_station(self, station):
        data = {
            'name_ar': station.name_ar,
            'name_en': station.name_en,
            'name_fr': station.name_fr,
            'latitude': station.latitude,
            'longitude': station.longitude,
            'paths': json.loads(station.paths) if station.paths else [],
            'changes': json.loads(station.changes) if station.changes else {},
            'schedule': json.loads(station.schedule) if station.schedule else [],
            'line_ids': sorted(station.line_ids.ids)
        }
        return json.dumps(data, sort_keys=True)







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\station\__init__.py
from . import station
from . import station_crud
from . import station_sync
from . import station_validation









// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\sync.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)

class InfrastructureSync(models.Model):
    _name = 'infrastructure.sync'
    _description = 'Infrastructure Synchronization'

    sync_type = fields.Selection([
        ('stations', 'Stations'),
        ('lines', 'Lines'),
        ('line_stations', 'Line Stations'),
    ], string="Sync Type", required=True, default='stations')

    def action_manual_sync(self):
        try:
            if self.sync_type == 'stations':
                result = self.env['infrastructure.station'].sync_infrastructure(sync_stations=True)
            elif self.sync_type == 'lines':
                result = self.env['infrastructure.line'].sync_infrastructure(sync_lines=True)
            elif self.sync_type == 'line_stations':
                result = self.env['infrastructure.line.station'].sync_infrastructure(sync_line_stations=True)
            message = _("Synchronization completed successfully: %s") % result
            _logger.info(message)
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _("Success"),
                    'message': message,
                    'type': 'success',
                    'sticky': False,
                }
            }
        except Exception as e:
            _logger.error("Synchronization failed: %s", str(e))
            raise UserError(_("Synchronization failed: %s") % str(e))







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\sync_wizard.py
from odoo import models, fields, api, _
from odoo.exceptions import UserError
import logging

_logger = logging.getLogger(__name__)

class InfrastructureSyncWizard(models.TransientModel):
    _name = 'infrastructure.sync.wizard'
    _description = 'Infrastructure Synchronization Wizard'

    sync_stations = fields.Boolean(string="Sync Stations", default=True)
    sync_lines = fields.Boolean(string="Sync Lines", default=True)
    sync_line_stations = fields.Boolean(string="Sync Line Stations", default=True)

    def action_sync(self):
        try:
            result = {}
            if self.sync_stations:
                result.update(self.env['infrastructure.station'].sync_infrastructure(sync_stations=True))
            if self.sync_lines:
                result.update(self.env['infrastructure.line'].sync_infrastructure(sync_lines=True))
            if self.sync_line_stations:
                result.update(self.env['infrastructure.line.station'].sync_infrastructure(sync_line_stations=True))

            # Prepare message
            message_parts = []
            if 'stations' in result:
                message_parts.append(f"Stations: {result['stations']['created']} created, {result['stations']['updated']} updated, {result['stations']['deleted']} deleted")
            if 'lines' in result:
                message_parts.append(f"Lines: {result['lines']['created']} created, {result['lines']['updated']} updated, {result['lines']['deleted']} deleted")
            if 'line_stations' in result:
                message_parts.append(f"Line Stations: {result['line_stations']['created']} created, {result['line_stations']['updated']} updated, {result['line_stations']['deleted']} deleted")
            
            message = "\n".join(message_parts) or "No synchronization performed."
            
            _logger.info("Synchronization completed: %s", message)
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _("Success"),
                    'message': message,
                    'type': 'success',
                    'sticky': False,
                }
            }
        except Exception as e:
            _logger.error("Synchronization failed: %s", str(e))
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': _("Sync Failed"),
                    'message': str(e),
                    'type': 'danger',
                    'sticky': True,
                }
            }







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\models\__init__.py
from . import line
from . import station
from . import line_station
from . import sync
from . import sync_wizard









// [Folder] scripts








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\scripts\extract_code.js
const fs = require('fs');
const path = require('path');

// Go up one level to the main module directory
const sourceFolder = path.resolve(__dirname, '..');
const outputFile = path.join(__dirname, 'odoo_code_output.txt');
const extensions = ['.py', '.xml', '.csv','.js','.css']; // File types in your Odoo module

function concatenateFiles(folderPath, depth = 0) {
  const files = fs.readdirSync(folderPath);
  let fileContent = '';
  let folderContent = '';

  files.forEach(file => {
    const filePath = path.join(folderPath, file);
    const stats = fs.statSync(filePath);

    if (stats.isDirectory()) {
      const subContent = concatenateFiles(filePath, depth + 1);
      if (subContent && subContent.trim()) {
        folderContent += `\n\n\n\n\n\n\n\n// ${'  '.repeat(depth)}[Folder] ${file}\n${subContent}\n\n`;
      }
    } else {
      for (const ext of extensions) {
        if (file.endsWith(ext)) {
          const fileData = fs.readFileSync(filePath, 'utf-8');
          fileContent += `\n\n\n\n\n\n\n\n// ${filePath}\n${fileData}`;
          break;
        }
      }
    }
  });

  return folderContent + fileContent;
}

// Start with a clean output file
fs.writeFileSync(outputFile, '', 'utf-8');
const allContent = concatenateFiles(sourceFolder);
fs.appendFileSync(outputFile, allContent, 'utf-8');

console.log(` Code extracted to: ${outputFile}`);










// [Folder] security








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\security\ir.model.access.csv
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_infrastructure_line,infrastructure.line,model_infrastructure_line,base.group_user,1,1,1,1
access_infrastructure_station,infrastructure.station,model_infrastructure_station,base.group_user,1,1,1,1
access_infrastructure_line_station,infrastructure.line.station,model_infrastructure_line_station,base.group_user,1,1,1,1
access_infrastructure_sync,infrastructure.sync,model_infrastructure_sync,base.group_system,1,1,1,1









// [Folder] static








//   [Folder] src








//     [Folder] css








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\css\line_map.css
.o_line_map_container {
    height: 100%;
    width: 100%;
}

#line_map {
    height: 600px;
    width: 100%;
}







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\css\line_station_map.css
.o_line_station_map_container {
    height: 100%;
    width: 100%;
}

#map {
    height: 100%;
    width: 100%;
}







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\css\station_map.css
.o_station_map_container {
    height: 100%;
    width: 100%;
}

#map {
    height: 600px;
    width: 100%;
}











//     [Folder] js








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\js\line_map.js
/** @odoo-module **/

import { registry } from "@web/core/registry";
import { Component, onMounted, onWillStart, useRef } from "@odoo/owl";
import { loadJS, loadCSS } from "@web/core/assets";

class LineMapComponent extends Component {
    static template = "infrastructure_management.LineStationMapTemplate";

    setup() {
        this.mapContainer = useRef("map");
        this.map = null;
        this.lineStations = [];
        this.lines = [];
        this.stations = [];

        onWillStart(async () => {
            await Promise.all([
                loadJS("https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"),
                loadCSS("https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"),
            ]);
            await this.loadLineStationData();
            await this.loadLineData();
            await this.loadStationData();
        });

        onMounted(() => {
            this.renderMap();
        });
    }

    async loadLineStationData() {
        const response = await this.env.services.rpc("/web/dataset/call_kw/infrastructure.line.station/search_read", {
            model: "infrastructure.line.station",
            method: "search_read",
            args: [this.props.action.domain || []],
            kwargs: {
                fields: ["order", "direction", "lat", "lng", "line_id", "station_id", "external_id"],
                context: this.props.action.context || {},
            },
        });
        this.lineStations = response;
        console.log("Loaded line stations:", this.lineStations);
    }

    async loadLineData() {
        const response = await this.env.services.rpc("/web/dataset/call_kw/infrastructure.line/search_read", {
            model: "infrastructure.line",
            method: "search_read",
            args: [this.props.action.domain || []],
            kwargs: {
                fields: ["enterprise_code", "color", "departure_station_id", "terminus_station_id"],
                context: this.props.action.context || {},
            },
        });
        this.lines = response;
        console.log("Loaded lines:", this.lines);
    }

    async loadStationData() {
        // Collect station IDs from lineStations
        const stationIdsFromLineStations = [...new Set(this.lineStations.map(ls => ls.station_id[0]))];
        // Collect station IDs from lines (departure and terminus)
        const stationIdsFromLines = [
            ...new Set(this.lines.flatMap(line => [
                line.departure_station_id ? line.departure_station_id[0] : null,
                line.terminus_station_id ? line.terminus_station_id[0] : null,
            ]).filter(id => id))
        ];
        // Combine all station IDs
        const allStationIds = [...new Set([...stationIdsFromLineStations, ...stationIdsFromLines])];
        if (allStationIds.length === 0) return;

        const response = await this.env.services.rpc("/web/dataset/call_kw/infrastructure.station/search_read", {
            model: "infrastructure.station",
            method: "search_read",
            args: [[["id", "in", allStationIds]]],
            kwargs: {
                fields: ["name_en", "name_ar", "name_fr", "latitude", "longitude"],
            },
        });
        this.stations = response;
        console.log("Loaded stations:", this.stations);
    }

    openLineForm(lineId) {
        this.env.services.action.doAction({
            type: 'ir.actions.act_window',
            res_model: 'infrastructure.line',
            res_id: lineId,
            views: [[false, 'form']],
            view_mode: 'form',
            target: 'current',
        });
    }

    renderMap() {
        if (!this.mapContainer.el || !window.L) {
            console.error("Map container not found or Leaflet not loaded!");
            return;
        }

        const defaultCoords = [36.365, 6.6147];
        this.map = L.map(this.mapContainer.el).setView(defaultCoords, 13);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors',
            maxZoom: 19,
        }).addTo(this.map);

        // Add legend control
        const legend = L.control({ position: 'topright' });
        legend.onAdd = () => {
            const div = L.DomUtil.create('div', 'info legend');
            div.style.backgroundColor = 'white';
            div.style.padding = '10px';
            div.style.border = '1px solid #ccc';
            div.style.borderRadius = '5px';
            div.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            div.style.fontFamily = 'Arial, sans-serif';
            div.style.fontSize = '12px';
            div.innerHTML = `
                <div style="margin-bottom: 6px;">
                    <span style="display: inline-block; width: 20px; height: 4px; background-color: #00FF00; margin-right: 6px;"></span>GOING
                </div>
                <div style="margin-bottom: 6px;">
                    <span style="display: inline-block; width: 20px; height: 4px; background-color: #FF0000; margin-right: 6px;"></span>RETURNING
                </div>
                <div style="margin-bottom: 6px;">
                    <span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #007bff; margin-right: 6px;"></span>Departure
                </div>
                <div>
                    <span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #ff7800; margin-right: 6px;"></span>Terminus
                </div>
            `;
            return div;
        };
        legend.addTo(this.map);

        const bounds = [];
        // Group line stations by line_id and direction for polylines
        const lineGroups = {};
        this.lineStations.forEach(ls => {
            const key = `${ls.line_id[0]}_${ls.direction}`;
            if (!lineGroups[key]) {
                lineGroups[key] = [];
            }
            lineGroups[key].push(ls);
        });

        // Sort each group by order and draw polylines for lines with lineStations
        Object.keys(lineGroups).forEach(key => {
            const group = lineGroups[key].sort((a, b) => a.order - b.order);
            const coordinates = [];
            group.forEach(ls => {
                const station = this.stations.find(s => s.id === ls.station_id[0]);
                if (station && station.latitude && station.longitude) {
                    coordinates.push([station.latitude, station.longitude]);
                }
            });

            if (coordinates.length > 1) {
                const line = this.lines.find(l => l.id === group[0].line_id[0]);
                const polylineColor = group[0].direction === 'GOING' ? '#00FF00' : '#FF0000'; // Green for Going, Red for Returning
                const polyline = L.polyline(coordinates, {
                    color: polylineColor,
                    weight: 5,
                    opacity: 0.7,
                }).addTo(this.map);

                // Enhanced popup with line details and edit button
                let popupContent = `
                    <div style="min-width: 200px; font-family: Arial, sans-serif; font-size: 14px;">
                        <h3 style="margin: 0 0 10px; font-size: 16px; color: ${polylineColor};">${line ? line.enterprise_code : 'Unknown'}</h3>
                        <p style="margin: 5px 0;"><b>Color:</b> ${line ? line.color || 'N/A' : 'N/A'}</p>
                        <p style="margin: 5px 0;"><b>Direction:</b> ${group[0].direction}</p>
                        <div style="margin-top: 10px;">
                            <button class="btn btn-primary btn-sm line-edit-btn" 
                                    data-line-id="${line ? line.id : ''}">Edit</button>
                        </div>
                    </div>
                `;
                polyline.bindPopup(popupContent, { maxWidth: 300, minWidth: 200 });

                polyline.on('popupopen', () => {
                    const editButton = document.querySelector(`.line-edit-btn[data-line-id="${line ? line.id : ''}"]`);
                    if (editButton) {
                        editButton.addEventListener('click', () => {
                            this.openLineForm(line ? line.id : null);
                        });
                    }
                });
            }
        });

        // Handle lines without lineStations (only departure and terminus)
        this.lines.forEach(line => {
            const hasLineStations = this.lineStations.some(ls => ls.line_id[0] === line.id);
            if (!hasLineStations && line.departure_station_id && line.terminus_station_id) {
                const departureStation = this.stations.find(s => s.id === line.departure_station_id[0]);
                const terminusStation = this.stations.find(s => s.id === line.terminus_station_id[0]);
                if (departureStation && departureStation.latitude && departureStation.longitude &&
                    terminusStation && terminusStation.latitude && terminusStation.longitude) {
                    const coordinates = [
                        [departureStation.latitude, departureStation.longitude],
                        [terminusStation.latitude, terminusStation.longitude]
                    ];
                    const polyline = L.polyline(coordinates, {
                        color: line.color || '#000000',
                        weight: 5,
                        opacity: 0.7,
                    }).addTo(this.map);

                    let popupContent = `
                        <div style="min-width: 200px; font-family: Arial, sans-serif; font-size: 14px;">
                            <h3 style="margin: 0 0 10px; font-size: 16px; color: ${line.color || '#000000'};">${line.enterprise_code || 'Unknown'}</h3>
                            <p style="margin: 5px 0;"><b>Color:</b> ${line.color || 'N/A'}</p>
                            <div style="margin-top: 10px;">
                                <button class="btn btn-primary btn-sm line-edit-btn" 
                                        data-line-id="${line.id}">Edit</button>
                            </div>
                        </div>
                    `;
                    polyline.bindPopup(popupContent, { maxWidth: 300, minWidth: 200 });

                    polyline.on('popupopen', () => {
                        const editButton = document.querySelector(`.line-edit-btn[data-line-id="${line.id}"]`);
                        if (editButton) {
                            editButton.addEventListener('click', () => {
                                this.openLineForm(line.id);
                            });
                        }
                    });

                    // Add markers for departure and terminus
                    L.circleMarker([departureStation.latitude, departureStation.longitude], {
                        radius: 8,
                        fillColor: '#007bff',
                        color: '#fff',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8,
                    }).bindPopup(`<b>Departure:</b> ${line.enterprise_code}<br><b>Name:</b> ${departureStation.name_en}`).addTo(this.map);

                    L.circleMarker([terminusStation.latitude, terminusStation.longitude], {
                        radius: 8,
                        fillColor: '#ff7800',
                        color: '#fff',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8,
                    }).bindPopup(`<b>Terminus:</b> ${line.enterprise_code}<br><b>Name:</b> ${terminusStation.name_en}`).addTo(this.map);

                    coordinates.forEach(coord => bounds.push(coord));
                } else {
                    console.warn(`Skipping line ${line.enterprise_code} due to missing coordinates for departure or terminus station`);
                }
            }
        });

        // Add markers for line stations
        this.lineStations.forEach(ls => {
            const station = this.stations.find(s => s.id === ls.station_id[0]);
            const line = this.lines.find(l => l.id === ls.line_id[0]);
            if (station && station.latitude && station.longitude) {
                const latLng = [station.latitude, station.longitude];
                bounds.push(latLng);

                // Debug log to verify direction value
                console.log(`Line Station ID: ${ls.id}, Direction: ${ls.direction}, Marker Color: ${ls.direction === 'GOING' ? '#00FF00' : '#FF0000'}`);

                const markerColor = ls.direction === 'GOING' ? '#00FF00' : '#FF0000'; // Green for Going, Red for Returning
                const marker = L.marker(latLng, {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background-color: ${markerColor}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>`,
                        iconSize: [16, 16],
                        iconAnchor: [8, 8],
                        popupAnchor: [0, -8],
                    }),
                    title: station.name_en || 'Station',
                });

                let popupContent = `
                    <div style="min-width: 200px; font-family: Arial, sans-serif; font-size: 14px;">
                        <h3 style="margin: 0 0 10px; font-size: 16px; color: ${markerColor};">${station.name_en || 'Unknown'}</h3>
                        <p style="margin: 5px 0;"><b>Line:</b> ${line ? line.enterprise_code : 'Unknown'}</p>
                        <p style="margin: 5px 0;"><b>Direction:</b> ${ls.direction}</p>
                        <p style="margin: 5px 0;"><b>Order:</b> ${ls.order}</p>
                        <p style="margin: 5px 0;"><b>Coordinates:</b> (${station.latitude.toFixed(4)}, ${station.longitude.toFixed(4)})</p>
                        <p style="margin: 5px 0;"><b>External ID:</b> ${ls.external_id || 'N/A'}</p>
                    </div>
                `;

                marker.bindPopup(popupContent, {
                    maxWidth: 300,
                    minWidth: 200,
                });

                // Add marker directly to the map (no clustering)
                marker.addTo(this.map);
            } else {
                console.warn(`Skipping line station ${ls.id} due to missing station coordinates`);
            }
        });

        if (bounds.length > 0) {
            this.map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
        } else {
            this.env.services.notification.add("No valid line station coordinates found.", {
                type: "warning",
                title: "Map Warning",
            });
        }
    }
}

registry.category("actions").add("line_map_tag", LineMapComponent);







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\js\line_station_location_picker.js
/** @odoo-module **/

import { registry } from "@web/core/registry";
import { useService } from "@web/core/utils/hooks";
import { Component, onMounted, onWillStart, useRef, onWillRender } from "@odoo/owl";

class LineStationLocationPicker extends Component {
    static template = "infrastructure_management.LineStationLocationPickerTemplate";
    static props = {
        record: Object,
        readonly: { type: Boolean, optional: true },
        id: { type: String, optional: true },
        name: { type: String, optional: true },
    };

    setup() {
        this.orm = useService("orm");
        this.mapRef = useRef("map");
        this.defaultLat = 36.7538; // Algiers coordinates
        this.defaultLng = 3.0588;
        this.map = null;
        this.marker = null;

        onWillStart(() => {
            console.log("LineStationLocationPicker: onWillStart");
            console.log("Leaflet available:", !!window.L, "Version:", window.L?.version);
        });

        onWillRender(() => {
            console.log("LineStationLocationPicker: onWillRender");
            console.log("Map ref before render:", this.mapRef.el);
        });

        onMounted(() => {
            console.log("LineStationLocationPicker: mounted");
            console.log("Map ref after mount:", this.mapRef.el);
            if (!this.mapRef.el) {
                console.error("Map container not found in DOM");
                return;
            }

            // Log container styles and dimensions
            const styles = window.getComputedStyle(this.mapRef.el);
            const rect = this.mapRef.el.getBoundingClientRect();
            console.log("Map container styles:", {
                display: styles.display,
                width: styles.width,
                height: styles.height,
                visibility: styles.visibility,
            });
            console.log("Map container dimensions:", rect);

            if (!window.L) {
                console.error("Cannot initialize map: Leaflet is not available.");
                return;
            }

            try {
                // Initialize map
                console.log("Initializing Leaflet map...");
                this.map = window.L.map(this.mapRef.el, {
                    center: [this.defaultLat, this.defaultLng],
                    zoom: 10,
                });
                console.log("Map initialized:", this.map);

                // Add OpenStreetMap tile layer
                window.L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                    attribution: ' <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    maxZoom: 19,
                }).addTo(this.map);
                console.log("Tile layer added");

                // Get coordinates from record
                const lat = parseFloat(this.props.record.data.lat || this.defaultLat);
                const lng = parseFloat(this.props.record.data.lng || this.defaultLng);
                console.log("Record coordinates:", { lat, lng });

                if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
                    this.marker = window.L.marker([lat, lng]).addTo(this.map);
                    this.map.setView([lat, lng], 10);
                    console.log("Marker added at:", { lat, lng });
                } else {
                    console.warn("Using default coordinates:", { lat: this.defaultLat, lng: this.defaultLng });
                }

                // Add click event for non-readonly mode
                if (!this.props.readonly) {
                    this.map.on("click", (e) => {
                        const { lat, lng } = e.latlng;
                        console.log("Map clicked, new coordinates:", { lat, lng });
                        if (this.marker) {
                            this.marker.setLatLng([lat, lng]);
                        } else {
                            this.marker = window.L.marker([lat, lng]).addTo(this.map);
                        }
                        this.props.record.update({
                            lat: lat,
                            lng: lng,
                        });
                    });
                }
            } catch (error) {
                console.error("Error initializing map:", error);
            }
        });
    }

    willUnmount() {
        console.log("LineStationLocationPicker: willUnmount");
        if (this.map) {
            this.map.remove();
            this.map = null;
        }
    }
}

registry.category("fields").add("line_station_location_picker", {
    component: LineStationLocationPicker,
    supportedTypes: ["boolean"],
});







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\js\line_station_map.js
/** @odoo-module **/

import { registry } from "@web/core/registry";
import { Component, onMounted, onWillStart, useRef } from "@odoo/owl";
import { loadJS, loadCSS } from "@web/core/assets";

class LineStationMapComponent extends Component {
    static template = "infrastructure_management.LineStationMapTemplate";

    setup() {
        this.mapContainer = useRef("map");
        this.map = null;
        this.lineStations = [];
        this.lines = [];
        this.stations = [];

        onWillStart(async () => {
            await Promise.all([
                loadJS("https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"),
                loadCSS("https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"),
            ]);
            await this.loadLineStationData();
            await this.loadLineData();
            await this.loadStationData();
        });

        onMounted(() => {
            this.renderMap();
        });
    }

    async loadLineStationData() {
        const response = await this.env.services.rpc("/web/dataset/call_kw/infrastructure.line.station/search_read", {
            model: "infrastructure.line.station",
            method: "search_read",
            args: [this.props.action.domain || []],
            kwargs: {
                fields: ["order", "direction", "lat", "lng", "line_id", "station_id", "external_id"],
                context: this.props.action.context || {},
            },
        });
        this.lineStations = response;
        console.log("Loaded line stations:", this.lineStations);
    }

    async loadLineData() {
        const lineIds = [...new Set(this.lineStations.map(ls => ls.line_id[0]))];
        if (lineIds.length === 0) return;

        const response = await this.env.services.rpc("/web/dataset/call_kw/infrastructure.line/search_read", {
            model: "infrastructure.line",
            method: "search_read",
            args: [[["id", "in", lineIds]]],
            kwargs: {
                fields: ["enterprise_code", "color"],
            },
        });
        this.lines = response;
        console.log("Loaded lines:", this.lines);
    }

    async loadStationData() {
        const stationIds = [...new Set(this.lineStations.map(ls => ls.station_id[0]))];
        if (stationIds.length === 0) return;

        const response = await this.env.services.rpc("/web/dataset/call_kw/infrastructure.station/search_read", {
            model: "infrastructure.station",
            method: "search_read",
            args: [[["id", "in", stationIds]]],
            kwargs: {
                fields: ["name_en", "name_ar", "name_fr", "latitude", "longitude"],
            },
        });
        this.stations = response;
        console.log("Loaded stations:", this.stations);
    }

    openLineStationForm(lineStationId) {
        this.env.services.action.doAction({
            type: 'ir.actions.act_window',
            res_model: 'infrastructure.line.station',
            res_id: lineStationId,
            views: [[false, 'form']],
            view_mode: 'form',
            target: 'current',
        });
    }

    renderMap() {
        if (!this.mapContainer.el || !window.L) {
            console.error("Map container not found or Leaflet not loaded!");
            return;
        }

        const defaultCoords = [36.365, 6.6147];
        this.map = L.map(this.mapContainer.el).setView(defaultCoords, 13);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors',
            maxZoom: 19,
        }).addTo(this.map);

        // Add legend control
        const legend = L.control({ position: 'topright' });
        legend.onAdd = () => {
            const div = L.DomUtil.create('div', 'info legend');
            div.style.backgroundColor = 'white';
            div.style.padding = '10px';
            div.style.border = '1px solid #ccc';
            div.style.borderRadius = '5px';
            div.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            div.style.fontFamily = 'Arial, sans-serif';
            div.style.fontSize = '12px';
            div.innerHTML = `
                <div style="margin-bottom: 6px;">
                    <span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #00FF00; margin-right: 6px;"></span>GOING
                </div>
                <div>
                    <span style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #FF0000; margin-right: 6px;"></span>RETURNING
                </div>
            `;
            return div;
        };
        legend.addTo(this.map);

        const bounds = [];
        // Add markers for line stations without polylines
        this.lineStations.forEach(ls => {
            const station = this.stations.find(s => s.id === ls.station_id[0]);
            const line = this.lines.find(l => l.id === ls.line_id[0]);
            if (station && station.latitude && station.longitude) {
                const latLng = [station.latitude, station.longitude];
                bounds.push(latLng);

                // Debug log to verify direction value
                console.log(`Line Station ID: ${ls.id}, Direction: ${ls.direction}, Marker Color: ${ls.direction === 'GOING' ? '#00FF00' : '#FF0000'}`);

                const markerColor = ls.direction === 'GOING' ? '#00FF00' : '#FF0000'; // Green for Going, Red for Returning
                const marker = L.marker(latLng, {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background-color: ${markerColor}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>`,
                        iconSize: [16, 16],
                        iconAnchor: [8, 8],
                        popupAnchor: [0, -8],
                    }),
                    title: station.name_en || 'Station',
                });

                let popupContent = `
                    <div style="min-width: 200px; font-family: Arial, sans-serif; font-size: 14px;">
                        <h3 style="margin: 0 0 10px; font-size: 16px; color: ${markerColor};">${station.name_en || 'Unknown'}</h3>
                        <p style="margin: 5px 0;"><b>Line:</b> ${line ? line.enterprise_code : 'Unknown'}</p>
                        <p style="margin: 5px 0;"><b>Direction:</b> ${ls.direction}</p>
                        <p style="margin: 5px 0;"><b>Order:</b> ${ls.order}</p>
                        <p style="margin: 5px 0;"><b>Coordinates:</b> (${station.latitude.toFixed(4)}, ${station.longitude.toFixed(4)})</p>
                        <p style="margin: 5px 0;"><b>External ID:</b> ${ls.external_id || 'N/A'}</p>
                        <div style="margin-top: 10px;">
                            <button class="btn btn-primary btn-sm line-station-edit-btn" 
                                    data-line-station-id="${ls.id}">Edit</button>
                        </div>
                    </div>
                `;

                marker.bindPopup(popupContent, {
                    maxWidth: 300,
                    minWidth: 200,
                });

                marker.on('popupopen', () => {
                    const editButton = document.querySelector(`.line-station-edit-btn[data-line-station-id="${ls.id}"]`);
                    if (editButton) {
                        editButton.addEventListener('click', () => {
                            this.openLineStationForm(ls.id);
                        });
                    }
                });

                // Add marker directly to the map (no clustering)
                marker.addTo(this.map);
            } else {
                console.warn(`Skipping line station ${ls.id} due to missing station coordinates`);
            }
        });

        if (bounds.length > 0) {
            this.map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
        } else {
            this.env.services.notification.add("No valid line station coordinates found.", {
                type: "warning",
                title: "Map Warning",
            });
        }
    }
}

registry.category("actions").add("line_station_map_tag", LineStationMapComponent);







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\js\station_location_picker.js
/** @odoo-module **/

import { registry } from "@web/core/registry";
import { useService } from "@web/core/utils/hooks";
import { Component, onMounted, onWillStart, useRef, onWillRender } from "@odoo/owl";

class StationLocationPicker extends Component {
    static template = "infrastructure_management.StationLocationPickerTemplate";
    static props = {
        record: Object,
        readonly: { type: Boolean, optional: true },
        id: { type: String, optional: true },
        name: { type: String, optional: true },
    };

    setup() {
        this.orm = useService("orm");
        this.mapRef = useRef("map");
        this.defaultLat = 36.7538; // Algiers coordinates
        this.defaultLng = 3.0588;
        this.map = null;
        this.marker = null;

        onWillStart(() => {
            console.log("StationLocationPicker: onWillStart");
            console.log("Leaflet available:", !!window.L, "Version:", window.L?.version);
        });

        onWillRender(() => {
            console.log("StationLocationPicker: onWillRender");
            console.log("Map ref before render:", this.mapRef.el);
        });

        onMounted(() => {
            console.log("StationLocationPicker: mounted");
            console.log("Map ref after mount:", this.mapRef.el);
            if (!this.mapRef.el) {
                console.error("Map container not found in DOM");
                return;
            }

            // Log container styles and dimensions
            const styles = window.getComputedStyle(this.mapRef.el);
            const rect = this.mapRef.el.getBoundingClientRect();
            console.log("Map container styles:", {
                display: styles.display,
                width: styles.width,
                height: styles.height,
                visibility: styles.visibility,
            });
            console.log("Map container dimensions:", rect);

            if (!window.L) {
                console.error("Cannot initialize map: Leaflet is not available.");
                return;
            }

            try {
                // Initialize map
                console.log("Initializing Leaflet map...");
                this.map = window.L.map(this.mapRef.el, {
                    center: [this.defaultLat, this.defaultLng],
                    zoom: 10,
                });
                console.log("Map initialized:", this.map);

                // Add OpenStreetMap tile layer
                window.L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                    attribution: ' <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                    maxZoom: 19,
                }).addTo(this.map);
                console.log("Tile layer added");

                // Get coordinates from record
                const lat = parseFloat(this.props.record.data.latitude || this.defaultLat);
                const lng = parseFloat(this.props.record.data.longitude || this.defaultLng);
                console.log("Record coordinates:", { lat, lng });

                if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
                    this.marker = window.L.marker([lat, lng]).addTo(this.map);
                    this.map.setView([lat, lng], 10);
                    console.log("Marker added at:", { lat, lng });
                } else {
                    console.warn("Using default coordinates:", { lat: this.defaultLat, lng: this.defaultLng });
                }

                // Add click event for non-readonly mode
                if (!this.props.readonly) {
                    this.map.on("click", (e) => {
                        const { lat, lng } = e.latlng;
                        console.log("Map clicked, new coordinates:", { lat, lng });
                        if (this.marker) {
                            this.marker.setLatLng([lat, lng]);
                        } else {
                            this.marker = window.L.marker([lat, lng]).addTo(this.map);
                        }
                        this.props.record.update({
                            latitude: lat,
                            longitude: lng,
                        });
                    });
                }
            } catch (error) {
                console.error("Error initializing map:", error);
            }
        });
    }

    willUnmount() {
        console.log("StationLocationPicker: willUnmount");
        if (this.map) {
            this.map.remove();
            this.map = null;
        }
    }
}

registry.category("fields").add("station_location_picker", {
    component: StationLocationPicker,
    supportedTypes: ["boolean"], // Match the field type in station.py
});







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\js\station_map.js
/** @odoo-module **/

import { registry } from "@web/core/registry";
import { Component, onMounted, onWillStart, useRef } from "@odoo/owl";
import { loadJS, loadCSS } from "@web/core/assets";

class StationMapComponent extends Component {
    static template = "infrastructure_management.StationMapTemplate";

    setup() {
        this.mapContainer = useRef("map");
        this.map = null;
        this.stations = [];

        onWillStart(async () => {
            await Promise.all([
                loadJS("https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"),
                loadCSS("https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"),
                loadJS("https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"),
                loadCSS("https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"),
                loadCSS("https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"),
            ]);
            await this.loadStationData();
        });

        onMounted(() => {
            this.renderMap();
        });
    }

    async loadStationData() {
        const response = await this.env.services.rpc("/web/dataset/call_kw/infrastructure.station/search_read", {
            model: "infrastructure.station",
            method: "search_read",
            args: [this.props.action.domain || []],
            kwargs: {
                fields: ["name_en", "name_ar", "name_fr", "latitude", "longitude", "line_ids", "external_id"],
                context: this.props.action.context || {},
            },
        });
        this.stations = response;
        console.log("Loaded stations:", this.stations);
    }

    openStationForm(stationId) {
        this.env.services.action.doAction({
            type: 'ir.actions.act_window',
            res_model: 'infrastructure.station',
            res_id: stationId,
            views: [[false, 'form']],
            view_mode: 'form',
            target: 'current',
        });
    }

    renderMap() {
        if (!this.mapContainer.el || !window.L) {
            console.error("Map container not found or Leaflet not loaded!");
            return;
        }

        const defaultCoords = [36.365, 6.6147];
        this.map = L.map(this.mapContainer.el).setView(defaultCoords, 13);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ' OpenStreetMap contributors',
            maxZoom: 19,
        }).addTo(this.map);

        const markerClusterGroup = L.markerClusterGroup({
            spiderfyOnMaxZoom: true,
            showCoverageOnHover: true,
            zoomToBoundsOnClick: true,
        });

        const bounds = [];
        this.stations.forEach(station => {
            if (station.latitude && station.longitude) {
                const latLng = [station.latitude, station.longitude];
                bounds.push(latLng);

                // Use L.marker with a custom icon for better visibility
                const marker = L.marker(latLng, {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background-color: #007bff; width: 24px; height: 24px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12],
                        popupAnchor: [0, -12],
                    }),
                    title: station.name_en || 'Station',
                });

                // Enhanced popup content with better styling
                let popupContent = `
                    <div style="min-width: 200px; font-family: Arial, sans-serif; font-size: 14px;">
                        <h3 style="margin: 0 0 10px; font-size: 16px; color: #007bff;">${station.name_en || 'Unknown'}</h3>
                        <p style="margin: 5px 0;"><b>Name (AR):</b> ${station.name_ar || 'N/A'}</p>
                        <p style="margin: 5px 0;"><b>Name (FR):</b> ${station.name_fr || 'N/A'}</p>
                        <p style="margin: 5px 0;"><b>Coordinates:</b> (${station.latitude.toFixed(4)}, ${station.longitude.toFixed(4)})</p>
                        <p style="margin: 5px 0;"><b>External ID:</b> ${station.external_id || 'N/A'}</p>
                `;

                if (station.line_ids && station.line_ids.length > 0) {
                    popupContent += `<p style="margin: 5px 0;"><b>Lines:</b></p><ul style="margin: 0; padding-left: 20px;">`;
                    station.line_ids.forEach(lineId => {
                        popupContent += `<li>Line ID: ${lineId}</li>`;
                    });
                    popupContent += `</ul>`;
                } else {
                    popupContent += `<p style="margin: 5px 0;"><b>Lines:</b> None</p>`;
                }

                popupContent += `
                        <div style="margin-top: 10px;">
                            <button class="btn btn-primary btn-sm station-edit-btn" 
                                    data-station-id="${station.id}">Edit</button>
                        </div>
                    </div>
                `;

                marker.bindPopup(popupContent, {
                    maxWidth: 300,
                    minWidth: 200,
                });

                // Bind click event to the marker's popup content after it's opened
                marker.on('popupopen', () => {
                    const editButton = document.querySelector(`.station-edit-btn[data-station-id="${station.id}"]`);
                    if (editButton) {
                        editButton.addEventListener('click', () => {
                            this.openStationForm(station.id);
                        });
                    }
                });

                markerClusterGroup.addLayer(marker);
            } else {
                console.warn(`Skipping station ${station.name_en || station.id} due to missing coordinates`);
            }
        });

        this.map.addLayer(markerClusterGroup);

        if (bounds.length > 0) {
            this.map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
        } else {
            this.env.services.notification.add("No valid station coordinates found.", {
                type: "warning",
                title: "Map Warning",
            });
        }
    }
}

registry.category("actions").add("station_map_tag", StationMapComponent);









//     [Folder] xml








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\xml\line_map_templates.xml
<?xml version="1.0" encoding="UTF-8"?>
<templates xml:space="preserve">
    <t t-name="infrastructure_management.line_map">
        <div class="o_line_map_container" style="height: 100%; width: 100%;">
            <div t-ref="map" id="line_map" style="height: 600px; width: 100%;"></div>
        </div>
    </t>
</templates>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\xml\line_station_location_picker_templates.xml
<?xml version="1.0" encoding="UTF-8"?>
<templates id="template" xml:space="preserve">
    <t t-name="infrastructure_management.LineStationLocationPickerTemplate">
        <div class="o_line_station_location_picker" style="width: 100%; height: 300px; position: relative; z-index: 0;">
            <div t-ref="map" style="width: 100%; height: 100%;"></div>
        </div>
    </t>
</templates>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\xml\line_station_map_templates.xml
<?xml version="1.0" encoding="UTF-8"?>
<templates xml:space="preserve">
    <t t-name="infrastructure_management.LineStationMapTemplate">
        <div class="o_line_station_map_container" style="height: 100%; width: 100%;">
            <div t-ref="map" id="map" style="height: 100%; width: 100%;"></div>
        </div>
    </t>
</templates>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\xml\station_location_picker_templates.xml
<?xml version="1.0" encoding="UTF-8"?>
<templates id="template" xml:space="preserve">
    <t t-name="infrastructure_management.StationLocationPickerTemplate">
        <div class="o_station_location_picker" style="width: 100%; height: 300px; position: relative; z-index: 0;">
            <div t-ref="map" style="width: 100%; height: 100%;"></div>
        </div>
    </t>
</templates>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\static\src\xml\station_map_templates.xml
<?xml version="1.0" encoding="UTF-8"?>
<templates xml:space="preserve">
    <t t-name="infrastructure_management.StationMapTemplate">
        <div class="o_station_map_container" style="height: 100%; width: 100%;">
            <div t-ref="map" id="map" style="height: 600px; width: 100%;"></div>
        </div>
    </t>
</templates>













// [Folder] views








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\views\line_station_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <data>
        <!-- Delete conflicting ir.actions.act_window record -->
        <delete model="ir.actions.act_window" id="infrastructure_management.action_infrastructure_line_station_map"/>

        <!-- Line Station Tree View -->
        <record id="view_infrastructure_line_station_tree" model="ir.ui.view">
            <field name="name">infrastructure.line.station.tree</field>
            <field name="model">infrastructure.line.station</field>
            <field name="arch" type="xml">
                <tree string="Line Stations">
                    <field name="order"/>
                    <field name="stop_duration"/>
                    <field name="direction"/>
                    <field name="lat"/>
                    <field name="lng"/>
                    <field name="line_id" widget="many2one"/>
                    <field name="station_id" widget="many2one"/>
                    <field name="alertable"/>
                    <field name="efficient"/>
                    <field name="duration"/>
                    <field name="external_id" readonly="1"/>
                </tree>
            </field>
        </record>

        <!-- Line Station Form View -->
        <record id="view_infrastructure_line_station_form" model="ir.ui.view">
            <field name="name">infrastructure.line.station.form</field>
            <field name="model">infrastructure.line.station</field>
            <field name="arch" type="xml">
                <form string="Line Station">
                    <sheet>
                        <group>
                            <group string="Line Station Details">
                                <field name="order" required="1"/>
                                <field name="stop_duration"/>
                                <field name="direction" required="1"/>
                                <field name="location_picker" widget="line_station_location_picker"/>
                                <field name="lat"/>
                                <field name="lng"/>
                                <field name="alertable"/>
                                <field name="efficient"/>
                                <field name="duration"/>
                                <field name="external_id" readonly="1"/>
                            </group>
                            <group string="References">
                                <field name="line_id" required="1" widget="selection" options="{'no_create': True, 'no_open': True}"/>
                                <field name="station_id" required="1" widget="selection" options="{'no_create': True, 'no_open': True}"/>
                            </group>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Line Station Search View -->
        <record id="view_infrastructure_line_station_search" model="ir.ui.view">
            <field name="name">infrastructure.line.station.search</field>
            <field name="model">infrastructure.line.station</field>
            <field name="arch" type="xml">
                <search string="Line Stations">
                    <field name="line_id"/>
                    <field name="station_id"/>
                    <field name="external_id"/>
                    <filter string="Going Direction" name="going_direction" domain="[('direction', '=', 'GOING')]"/>
                    <filter string="Returning Direction" name="returning_direction" domain="[('direction', '=', 'RETURNING')]"/>
                    <filter string="With External ID" name="with_external_id" domain="[('external_id', '!=', False)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Line" name="group_by_line" context="{'group_by': 'line_id'}"/>
                        <filter string="Station" name="group_by_station" context="{'group_by': 'station_id'}"/>
                        <filter string="Direction" name="group_by_direction" context="{'group_by': 'direction'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Line Station List Action -->
        <record id="action_infrastructure_line_station" model="ir.actions.act_window">
            <field name="name">Line Stations</field>
            <field name="res_model">infrastructure.line.station</field>
            <field name="view_mode">tree,form</field>
            <field name="view_id" ref="view_infrastructure_line_station_tree"/>
            <field name="search_view_id" ref="view_infrastructure_line_station_search"/>
        </record>

        <!-- Line Station Map Action -->
        <record id="action_infrastructure_line_station_map" model="ir.actions.client">
            <field name="name">Line Stations Map</field>
            <field name="tag">line_station_map_tag</field>
        </record>
    </data>
</odoo>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\views\line_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <data>
        <!-- Line Tree View -->
        <record id="view_infrastructure_line_tree" model="ir.ui.view">
            <field name="name">infrastructure.line.tree</field>
            <field name="model">infrastructure.line</field>
            <field name="arch" type="xml">
                <tree string="Lines">
                    <field name="enterprise_code"/>
                    <field name="code"/>
                    <field name="color" widget="color"/>
                    <field name="departure_station_id" widget="many2one"/>
                    <field name="terminus_station_id" widget="many2one"/>
                    <field name="external_id" readonly="1"/>
                </tree>
            </field>
        </record>

        <!-- Line Form View -->
        <record id="view_infrastructure_line_form" model="ir.ui.view">
            <field name="name">infrastructure.line.form</field>
            <field name="model">infrastructure.line</field>
            <field name="arch" type="xml">
                <form string="Line">
                    <sheet>
                        <group>
                            <group string="Line Details">
                                <field name="enterprise_code" required="1"/>
                                <field name="code" required="1"/>
                                <field name="color" required="1" widget="color"/>
                                <field name="external_id" readonly="1"/>
                            </group>
                            <group string="Stations">
                                <field name="departure_station_id" widget="selection" options="{'no_create': True, 'no_open': True}"/>
                                <field name="terminus_station_id" widget="selection" options="{'no_create': True, 'no_open': True}"/>
                            </group>
                        </group>
                        <group string="Additional Information">
                            <field name="schedule"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Line Search View -->
        <record id="view_infrastructure_line_search" model="ir.ui.view">
            <field name="name">infrastructure.line.search</field>
            <field name="model">infrastructure.line</field>
            <field name="arch" type="xml">
                <search string="Lines">
                    <field name="enterprise_code"/>
                    <field name="code"/>
                    <field name="external_id"/>
                    <filter string="With External ID" name="with_external_id" domain="[('external_id', '!=', False)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Departure Station" name="group_by_departure" context="{'group_by': 'departure_station_id'}"/>
                        <filter string="Terminus Station" name="group_by_terminus" context="{'group_by': 'terminus_station_id'}"/>
                    </group>
                </search>
            </field>
        </record>

        <!-- Line List Action -->
        <record id="action_infrastructure_line" model="ir.actions.act_window">
            <field name="name">Lines</field>
            <field name="res_model">infrastructure.line</field>
            <field name="view_mode">tree,form</field>
            <field name="view_id" ref="view_infrastructure_line_tree"/>
            <field name="search_view_id" ref="view_infrastructure_line_search"/>
        </record>

        <!-- Delete the old ir.actions.act_window record -->
        <delete model="ir.actions.act_window" id="infrastructure_management.action_infrastructure_line_map"/>

        <!-- Line Map Action (Client Action for OWL Component) -->
        <record id="action_infrastructure_line_map" model="ir.actions.client">
            <field name="name">Lines Map</field>
            <field name="tag">line_map_tag</field>
        </record>

        <!-- Remove Manual Sync Action -->
        <delete model="ir.actions.server" id="infrastructure_management.action_sync_lines"/>
    </data>
</odoo>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\views\menu.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <data>
        <!-- Top-level menu: Infrastructure -->
        <menuitem
            id="menu_infrastructure_root"
            name="Infrastructure"
            sequence="10"
        />

        <!-- Stations sub-menu -->
        <menuitem
            id="menu_infrastructure_stations"
            name="Stations"
            parent="menu_infrastructure_root"
            sequence="10"
        />

        <!-- Stations: List View -->
        <menuitem
            id="menu_infrastructure_stations_list"
            name="List View"
            parent="menu_infrastructure_stations"
            action="infrastructure_management.action_infrastructure_station"
            sequence="10"
        />

        <!-- Stations: Map View -->
        <menuitem
            id="menu_infrastructure_stations_map"
            name="Map View"
            parent="menu_infrastructure_stations"
            action="infrastructure_management.action_infrastructure_station_map"
            sequence="20"
        />

        <!-- Lines sub-menu -->
        <menuitem
            id="menu_infrastructure_lines"
            name="Lines"
            parent="menu_infrastructure_root"
            sequence="20"
        />

        <!-- Lines: List View -->
        <menuitem
            id="menu_infrastructure_lines_list"
            name="List View"
            parent="menu_infrastructure_lines"
            action="infrastructure_management.action_infrastructure_line"
            sequence="10"
        />

        <!-- Lines: Map View -->
        <menuitem
            id="menu_infrastructure_lines_map"
            name="Map View"
            parent="menu_infrastructure_lines"
            action="infrastructure_management.action_infrastructure_line_map"
            sequence="20"
        />

        <!-- Line Stations sub-menu -->
        <menuitem
            id="menu_infrastructure_line_stations"
            name="Line Stations"
            parent="menu_infrastructure_root"
            sequence="30"
        />

        <!-- Line Stations: List View -->
        <menuitem
            id="menu_infrastructure_line_stations_list"
            name="List View"
            parent="menu_infrastructure_line_stations"
            action="infrastructure_management.action_infrastructure_line_station"
            sequence="10"
        />

        <!-- Line Stations: Map View -->
        <menuitem
            id="menu_infrastructure_line_stations_map"
            name="Map View"
            parent="menu_infrastructure_line_stations"
            action="infrastructure_management.action_infrastructure_line_station_map"
            sequence="20"
        />
    </data>
</odoo>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\views\station_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <data>
        <record id="view_infrastructure_station_tree" model="ir.ui.view">
            <field name="name">infrastructure.station.tree</field>
            <field name="model">infrastructure.station</field>
            <field name="arch" type="xml">
                <tree string="Stations">
                    <field name="name_en"/>
                    <field name="name_ar"/>
                    <field name="name_fr"/>
                    <field name="latitude"/>
                    <field name="longitude"/>
                    <field name="line_ids" widget="many2many_tags"/>
                    <field name="external_id" readonly="1"/>
                </tree>
            </field>
        </record>

        <record id="view_infrastructure_station_form" model="ir.ui.view">
            <field name="name">infrastructure.station.form</field>
            <field name="model">infrastructure.station</field>
            <field name="arch" type="xml">
                <form string="Station">
                    <sheet>
                        <group>
                            <group string="Station Details">
                                <field name="name_en" required="1"/>
                                <field name="name_ar" required="1"/>
                                <field name="name_fr" required="1"/>
                                <field name="external_id" readonly="1"/>
                            </group>
                            <group string="Location">
                                <field name="location_picker" widget="station_location_picker"/>
                                <field name="latitude"/>
                                <field name="longitude"/>
                            </group>
                        </group>
                        <group string="Additional Information">
                            <field name="paths"/>
                            <field name="schedule"/>
                            <field name="changes"/>
                            <field name="line_ids" widget="many2many_tags"/>
                        </group>
                    </sheet>
                </form>
            </field>
        </record>

        <record id="view_infrastructure_station_search" model="ir.ui.view">
            <field name="name">infrastructure.station.search</field>
            <field name="model">infrastructure.station</field>
            <field name="arch" type="xml">
                <search string="Stations">
                    <field name="name_en"/>
                    <field name="name_ar"/>
                    <field name="name_fr"/>
                    <field name="external_id"/>
                    <filter string="With External ID" name="with_external_id" domain="[('external_id', '!=', False)]"/>
                    <filter string="Without External ID" name="without_external_id" domain="[('external_id', '=', False)]"/>
                    <group expand="0" string="Group By">
                        <filter string="Lines" name="group_by_lines" context="{'group_by': 'line_ids'}"/>
                    </group>
                </search>
            </field>
        </record>

        <record id="action_infrastructure_station" model="ir.actions.act_window">
            <field name="name">Stations</field>
            <field name="res_model">infrastructure.station</field>
            <field name="view_mode">tree,form</field>
            <field name="view_id" ref="view_infrastructure_station_tree"/>
            <field name="search_view_id" ref="view_infrastructure_station_search"/>
        </record>

        <record id="action_infrastructure_station_map" model="ir.actions.client">
            <field name="name">Stations Map</field>
            <field name="tag">station_map_tag</field>
        </record>
    </data>
</odoo>







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\views\sync_views.xml
<?xml version="1.0" encoding="UTF-8"?>
<odoo>
    <data>
        <!-- Sync Form View -->
        <record id="view_infrastructure_sync_form" model="ir.ui.view">
            <field name="name">infrastructure.sync.form</field>
            <field name="model">infrastructure.sync</field>
            <field name="arch" type="xml">
                <form string="Manual Sync">
                    <sheet>
                        <group>
                            <p>Select the data to synchronize from the external API.</p>
                            <field name="sync_type" widget="selection" required="1"/>
                        </group>
                        <footer>
                            <button name="action_manual_sync" type="object" string="Sync Now" class="btn-primary"/>
                            <button special="cancel" string="Cancel" class="btn-secondary"/>
                        </footer>
                    </sheet>
                </form>
            </field>
        </record>

        <!-- Sync Action -->
        <record id="action_infrastructure_sync" model="ir.actions.act_window">
            <field name="name">Manual Sync</field>
            <field name="res_model">infrastructure.sync</field>
            <field name="view_mode">form</field>
            <field name="view_id" ref="view_infrastructure_sync_form"/>
            <field name="target">new</field>
        </record>

        <!-- Menu Item -->
        <menuitem
            id="menu_infrastructure_sync"
            name="Manual Sync"
            parent="menu_infrastructure_root"
            action="action_infrastructure_sync"
            sequence="40"
        />
    </data>
</odoo>









// [Folder] wizards








// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\wizards\sync_wizard.py
from odoo import models, fields, api
from odoo.exceptions import UserError

class InfrastructureSyncWizard(models.TransientModel):
    _name = 'infrastructure.sync.wizard'
    _description = 'Infrastructure Sync Wizard'

    sync_stations = fields.Boolean(string='Sync Stations', default=True)
    sync_lines = fields.Boolean(string='Sync Lines', default=True)
    sync_line_stations = fields.Boolean(string='Sync Line Stations', default=True)

    def action_sync(self):
        """Execute the synchronization based on selected options"""
        try:
            station_model = self.env['infrastructure.station']
            result = station_model.sync_infrastructure(
                sync_stations=self.sync_stations,
                sync_lines=self.sync_lines,
                sync_line_stations=self.sync_line_stations
            )
            
            # Prepare message
            message_parts = []
            if self.sync_stations:
                message_parts.append(f"Stations: {result['stations']['synced']} synced, {result['stations']['skipped']} skipped")
            if self.sync_lines:
                message_parts.append(f"Lines: {result['lines']['synced']} synced, {result['lines']['skipped']} skipped")
            if self.sync_line_stations:
                message_parts.append(f"Line Stations: {result['line_stations']['synced']} synced, {result['line_stations']['skipped']} skipped")
            
            message = "\n".join(message_parts)
            
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Sync Complete',
                    'message': message,
                    'sticky': False,
                    'type': 'success',
                }
            }
        except Exception as e:
            return {
                'type': 'ir.actions.client',
                'tag': 'display_notification',
                'params': {
                    'title': 'Sync Failed',
                    'message': str(e),
                    'sticky': True,
                    'type': 'danger',
                }
            } 







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\wizards\sync_wizard_view.xml
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record id="view_infrastructure_sync_wizard_form" model="ir.ui.view">
        <field name="name">infrastructure.sync.wizard.form</field>
        <field name="model">infrastructure.sync.wizard</field>
        <field name="arch" type="xml">
            <form string="Sync Infrastructure">
                <p class="text-muted">
                    Select which infrastructure elements you want to synchronize from the API.
                </p>
                <group>
                    <field name="sync_stations"/>
                    <field name="sync_lines"/>
                    <field name="sync_line_stations"/>
                </group>
                <footer>
                    <button string="Sync" name="action_sync" type="object" class="btn-primary"/>
                    <button string="Cancel" class="btn-secondary" special="cancel"/>
                </footer>
            </form>
        </field>
    </record>

    <record id="action_infrastructure_sync_wizard" model="ir.actions.act_window">
        <field name="name">Sync Infrastructure</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">infrastructure.sync.wizard</field>
        <field name="view_mode">form</field>
        <field name="target">new</field>
    </record>

    <!-- Menu item -->
    <menuitem id="menu_infrastructure_sync"
              name="Sync Infrastructure"
              parent="menu_infrastructure_management"
              action="action_infrastructure_sync_wizard"
              sequence="20"/>
</odoo> 







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\wizards\__init__.py
from . import sync_wizard 









// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\__init__.py
from . import models







// C:\Users\kebic\OneDrive\Desktop\rest_api_v1\odoo-project\odoo\custom_addons\infrastructure_management\__manifest__.py
{
    'name': 'Infrastructure Management',
    'version': '1.16',  # Incremented from 1.15
    'summary': 'Manage transportation lines, stations, and line stations',
    'description': 'A module to manage lines, stations, line stations, and integrate with etrans_infrastructure API.',
    'category': 'Tools',
    'author': 'kebiche fouez',
    'depends': ['base', 'web', 'mail'],
    'data': [
        'security/ir.model.access.csv',
        'data/cron.xml',
        'views/line_views.xml',
        'views/station_views.xml',
        'views/line_station_views.xml',
        'views/menu.xml',
        'views/sync_views.xml',
    ],
    'assets': {
        'web.assets_backend': [
            'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
            'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
            'https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js',
            'https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css',
            'https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css',
            'infrastructure_management/static/src/css/station_map.css',
            'infrastructure_management/static/src/css/line_map.css',
            'infrastructure_management/static/src/css/line_station_map.css',
            'infrastructure_management/static/src/js/station_map.js',
            'infrastructure_management/static/src/js/line_map.js',
            'infrastructure_management/static/src/js/line_station_map.js',
            'infrastructure_management/static/src/js/station_location_picker.js',
            'infrastructure_management/static/src/js/line_station_location_picker.js',  # Added
            'infrastructure_management/static/src/xml/station_map_templates.xml',
            'infrastructure_management/static/src/xml/line_map_templates.xml',
            'infrastructure_management/static/src/xml/line_station_map_templates.xml',
            'infrastructure_management/static/src/xml/station_location_picker_templates.xml',
            'infrastructure_management/static/src/xml/line_station_location_picker_templates.xml',  # Added
        ],
    },
    'installable': True,
    'application': True,
    'license': 'LGPL-3',
}